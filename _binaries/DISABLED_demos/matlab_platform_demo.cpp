#include "networking/document/web_components.h"
#include "auth/auth_system.h"
#include "services/cache_server/cache_server.h"
#include "services/distributed_fs/distributed_fs.h"
#include "services/mail_server/mail_server.h"
#include "services/url_shortener/url_shortener.h"
#include "system_monitor.h"
#include "services/service_breaker/service_breaker.h"
#include "ml_server/ml_server.h"
#include "app_launcher_html.h"
#include <iostream>
#include <iomanip>
#include <thread>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <sstream>
#include <map>
#include <sys/stat.h>
#include <fstream>
#include <fcntl.h>
#include <vector>
#include <atomic>
#include <deque>
#include <mutex>
#include <chrono>
#include <iomanip>
#include <sys/ioctl.h>
#include <signal.h>
#include <sys/wait.h>

using namespace ml::networking::html;
using namespace auth;

// Get terminal dimensions
struct TerminalSize {
    int rows;
    int cols;
};

TerminalSize get_terminal_size() {
    struct winsize w;
    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);
    return {w.ws_row, w.ws_col};
}

// Thread-safe request logger
class RequestLogger {
public:
    struct LogEntry {
        std::string timestamp;
        std::string method;
        std::string path;
        std::thread::id thread_id;
    };
    
    void log_request(const std::string& method, const std::string& path, std::thread::id tid) {
        std::lock_guard<std::mutex> lock(mutex_);
        
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;
        
        std::stringstream ss;
        ss << std::put_time(std::localtime(&time_t), "%H:%M:%S")
           << "." << std::setfill('0') << std::setw(3) << ms.count();
        
        LogEntry entry{ss.str(), method, path, tid};
        logs_.push_back(entry);
        
        // Keep only last 50 requests
        if (logs_.size() > 50) {
            logs_.pop_front();
        }
    }
    
    std::vector<LogEntry> get_recent_logs(size_t count = 15) {
        std::lock_guard<std::mutex> lock(mutex_);
        std::vector<LogEntry> result;
        
        size_t start = logs_.size() > count ? logs_.size() - count : 0;
        for (size_t i = start; i < logs_.size(); i++) {
            result.push_back(logs_[i]);
        }
        
        return result;
    }
    
private:
    std::deque<LogEntry> logs_;
    std::mutex mutex_;
};

// Service structures and manager (defined early for use by MATLABStyleUI)
struct ServiceInfo {
    std::string name;
    std::string command;
    int port;
    pid_t pid;
    bool running;
    std::string description;
    std::vector<std::string> output_lines;
    int output_fd;
    int build_retry_count = 0;  // Track retry attempts
};

struct WatchedFileInfo {
    std::string filepath;
    time_t last_modified;
    time_t last_checked;
    std::vector<int> associated_services; // Service IDs that depend on this file
    bool is_header;
};

struct LibraryInfo {
    std::string name;
    std::string path;
    std::string version;
};

struct ServiceBuildInfo {
    int service_id;
    std::string executable_path;
    size_t file_size;
    time_t last_built;
    std::vector<LibraryInfo> linked_libraries;
    std::vector<std::string> source_files;
};

struct SharedLibraryInfo {
    std::string name;
    std::string path;
    std::string target_name;
    size_t file_size;
    time_t last_modified;
    std::string make_command;
};

class ServiceManager {
private:
    std::map<int, ServiceInfo> services_;
    std::mutex mutex_;
    std::atomic<bool> running_{true};
    std::thread output_reader_;
    std::thread file_watcher_;
    std::map<std::string, time_t> watched_files_mtimes_;
    std::vector<WatchedFileInfo> watched_files_list_;
    std::map<int, ServiceBuildInfo> build_info_cache_;
    std::atomic<uint64_t> watchdog_checks_{0};
    std::atomic<uint64_t> watchdog_rebuilds_{0};
    std::atomic<uint64_t> watchdog_restarts_{0};
    std::chrono::steady_clock::time_point watchdog_start_time_;
    bool use_nginx_ = false;
    std::string nginx_conf_dir_ = "/usr/local/etc/nginx/servers/";
    
    // Check if nginx is installed
    bool is_nginx_installed() {
        FILE* pipe = popen("which nginx 2>/dev/null", "r");
        if (!pipe) return false;
        
        char buffer[128];
        bool found = (fgets(buffer, sizeof(buffer), pipe) != nullptr);
        pclose(pipe);
        return found;
    }
    
    // Generate nginx config for a service
    std::string generate_nginx_config(int service_id, const ServiceInfo& svc) {
        std::stringstream conf;
        conf << "# Service: " << svc.name << " (ID: " << service_id << ")\n";
        conf << "# Auto-generated by Service Manager\n\n";
        conf << "upstream service_" << service_id << " {\n";
        conf << "    server 127.0.0.1:" << svc.port << ";\n";
        conf << "}\n\n";
        conf << "server {\n";
        conf << "    listen 80" << service_id << ";\n"; // e.g., 8002 for service 2
        conf << "    server_name localhost;\n\n";
        conf << "    location / {\n";
        conf << "        proxy_pass http://service_" << service_id << ";\n";
        conf << "        proxy_http_version 1.1;\n";
        conf << "        proxy_set_header Upgrade $http_upgrade;\n";
        conf << "        proxy_set_header Connection 'upgrade';\n";
        conf << "        proxy_set_header Host $host;\n";
        conf << "        proxy_cache_bypass $http_upgrade;\n";
        conf << "        proxy_set_header X-Real-IP $remote_addr;\n";
        conf << "        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n";
        conf << "        proxy_set_header X-Forwarded-Proto $scheme;\n";
        conf << "    }\n";
        conf << "}\n";
        return conf.str();
    }
    
    // Write nginx config file
    bool write_nginx_config(int service_id, const std::string& config) {
        if (!use_nginx_) return false;
        
        std::string filename = nginx_conf_dir_ + "service_" + std::to_string(service_id) + ".conf";
        std::ofstream file(filename);
        if (!file.is_open()) {
            std::cerr << "[nginx] Failed to write config: " << filename << "\n";
            return false;
        }
        
        file << config;
        file.close();
        std::cout << "[nginx] Config written: " << filename << "\n";
        return true;
    }
    
    // Read nginx config file
    std::string read_nginx_config(int service_id) {
        std::string filename = nginx_conf_dir_ + "service_" + std::to_string(service_id) + ".conf";
        std::ifstream file(filename);
        if (!file.is_open()) {
            return "# Config file not found: " + filename;
        }
        
        std::stringstream buffer;
        buffer << file.rdbuf();
        return buffer.str();
    }
    
    // Reload nginx
    bool reload_nginx() {
        if (!use_nginx_) return false;
        
        std::cout << "[nginx] Testing configuration...\n";
        int test_result = system("nginx -t 2>&1");
        if (test_result != 0) {
            std::cerr << "[nginx] Configuration test failed!\n";
            return false;
        }
        
        std::cout << "[nginx] Reloading nginx...\n";
        int reload_result = system("nginx -s reload 2>&1");
        if (reload_result == 0) {
            std::cout << "[nginx] âœ“ Nginx reloaded successfully\n";
            return true;
        } else {
            std::cerr << "[nginx] Failed to reload nginx\n";
            return false;
        }
    }
    
    // Check if a process is still alive
    bool is_process_alive(pid_t pid) {
        if (pid <= 0) return false;
        // kill with signal 0 checks if process exists without actually sending a signal
        return (kill(pid, 0) == 0);
    }
    
    // Check if Bun.js is installed
    bool is_bun_installed() {
        FILE* pipe = popen("which bun 2>/dev/null", "r");
        if (!pipe) return false;
        
        char buffer[128];
        bool found = (fgets(buffer, sizeof(buffer), pipe) != nullptr);
        pclose(pipe);
        return found;
    }
    
    // Try to build a service executable
    bool build_service(int id, const std::string& service_name, std::vector<std::string>& build_output) {
        std::cout << "[ServiceManager] Attempting to build " << service_name << "...\n";
        build_output.push_back("[BUILD] Attempting to build " + service_name + "...");
        
        // Determine build command based on service
        std::string build_cmd;
        if (id == 2 || id == 3) {
            // Backend services in services/ directory
            build_cmd = "cd /Users/mehranghamaty/wkspace/ToolBox/services && cmake --build build -j8 2>&1";
            build_output.push_back("[BUILD] Command: " + build_cmd);
        } else {
            build_output.push_back("[BUILD] ERROR: Don't know how to build this service");
            return false; // Don't know how to build this service
        }
        
        build_output.push_back("[BUILD] Starting build process...");
        build_output.push_back("");
        
        FILE* pipe = popen(build_cmd.c_str(), "r");
        if (!pipe) {
            build_output.push_back("[BUILD] ERROR: Failed to run build command");
            return false;
        }
        
        char buffer[256];
        int line_count = 0;
        while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
            std::string line = buffer;
            // Remove trailing newline
            if (!line.empty() && line[line.length()-1] == '\n') {
                line.erase(line.length()-1);
            }
            build_output.push_back(line);
            line_count++;
            
            // Also print to stdout for debugging
            if (line_count <= 10 || line.find("Built target") != std::string::npos || 
                line.find("error") != std::string::npos || line.find("Error") != std::string::npos) {
                std::cout << "[BUILD] " << line << "\n";
            }
        }
        
        int result = pclose(pipe);
        build_output.push_back("");
        build_output.push_back("[BUILD] Build process completed with exit code: " + std::to_string(result));
        std::cout << "[ServiceManager] Build completed with exit code: " << result << "\n";
        
        return (result == 0);
    }
    
    void watch_service_files() {
        std::cout << "[FileWatcher] Starting service file monitor...\n";
        std::cout << "[FileWatcher] Auto-discovering C++ services in services/ directory...\n";
        
        while (running_) {
            watchdog_checks_++;
            sleep(2); // Check every 2 seconds
            
            // Auto-discover all .cpp files in services/ and libraries/include/
            std::vector<std::string> watch_paths;
            
            // Get current working directory to build relative paths
            char cwd[1024];
            getcwd(cwd, sizeof(cwd));
            std::string base_path = std::string(cwd);
            
            // Watch all .cpp files in services/
            std::string services_glob_cmd = "find " + base_path + "/services -maxdepth 1 -name '*.cpp' 2>/dev/null";
            FILE* services_pipe = popen(services_glob_cmd.c_str(), "r");
            if (services_pipe) {
                char path[1024];
                while (fgets(path, sizeof(path), services_pipe)) {
                    std::string filepath = path;
                    // Remove trailing newline
                    if (!filepath.empty() && filepath[filepath.length()-1] == '\n') {
                        filepath.erase(filepath.length()-1);
                    }
                    watch_paths.push_back(filepath);
                }
                pclose(services_pipe);
            }
            
            // Also watch header files that services might depend on
            std::string headers_glob_cmd = "find " + base_path + "/services -maxdepth 2 -name '*.h' -o -name '*.hpp' 2>/dev/null";
            FILE* headers_pipe = popen(headers_glob_cmd.c_str(), "r");
            if (headers_pipe) {
                char path[1024];
                while (fgets(path, sizeof(path), headers_pipe)) {
                    std::string filepath = path;
                    if (!filepath.empty() && filepath[filepath.length()-1] == '\n') {
                        filepath.erase(filepath.length()-1);
                    }
                    watch_paths.push_back(filepath);
                }
                pclose(headers_pipe);
            }
            
            // Update watched files list with metadata
            {
                std::lock_guard<std::mutex> lock(mutex_);
                watched_files_list_.clear();
                for (const auto& filepath : watch_paths) {
                    WatchedFileInfo info;
                    info.filepath = filepath;
                    struct stat file_stat;
                    if (stat(filepath.c_str(), &file_stat) == 0) {
                        info.last_modified = file_stat.st_mtime;
                    }
                    info.last_checked = std::time(nullptr);
                    info.is_header = (filepath.find(".h") != std::string::npos || filepath.find(".hpp") != std::string::npos);
                    
                    // Determine associated services
                    if (filepath.find("account_service") != std::string::npos) info.associated_services.push_back(3);
                    if (filepath.find("metrics_backend") != std::string::npos) info.associated_services.push_back(2);
                    if (filepath.find("proxy_service") != std::string::npos) info.associated_services.push_back(4);
                    if (info.is_header) {
                        // Headers affect all services
                        info.associated_services = {2, 3, 4};
                    }
                    
                    watched_files_list_.push_back(info);
                }
            }
            
            for (const auto& filepath : watch_paths) {
                struct stat file_stat;
                if (stat(filepath.c_str(), &file_stat) == 0) {
                    time_t mtime = file_stat.st_mtime;
                    
                    // Check if file was modified
                    if (watched_files_mtimes_.find(filepath) != watched_files_mtimes_.end()) {
                        if (watched_files_mtimes_[filepath] != mtime) {
                            // File changed!
                            std::string filename = filepath.substr(filepath.find_last_of("/") + 1);
                            
                            // Format timestamp
                            auto now = std::chrono::system_clock::now();
                            auto now_c = std::chrono::system_clock::to_time_t(now);
                            auto now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;
                            char time_buf[32];
                            std::strftime(time_buf, sizeof(time_buf), "%H:%M:%S", std::localtime(&now_c));
                            
                            std::cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
                            std::cout << "â•‘  ğŸ”„ SOURCE FILE CHANGED - AUTO-REBUILD TRIGGERED           â•‘\n";
                            std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
                            std::cout << "â•‘  Time:     " << time_buf << "." << std::setfill('0') << std::setw(3) << now_ms.count() << std::setfill(' ') << "                                           â•‘\n";
                            std::cout << "â•‘  File:     " << filename << std::string(51 - filename.length(), ' ') << "â•‘\n";
                            std::cout << "â•‘  Path:     " << filepath.substr(base_path.length() + 1) << std::string(51 - filepath.substr(base_path.length() + 1).length(), ' ') << "â•‘\n";
                            std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
                            
                            // Determine which service(s) to rebuild based on filename
                            // Map service names to IDs
                            std::map<std::string, int> service_map = {
                                {"account_service", 3},
                                {"metrics_backend_service", 2},
                                {"proxy_service", 4}
                            };
                            
                            // Find matching service
                            int service_id = -1;
                            std::string matched_service_name;
                            for (const auto& [svc_name, svc_id] : service_map) {
                                if (filepath.find(svc_name) != std::string::npos) {
                                    service_id = svc_id;
                                    matched_service_name = svc_name;
                                    break;
                                }
                            }
                            
                            // If it's a header file, rebuild all services that might depend on it
                            bool is_header = (filepath.find(".h") != std::string::npos || filepath.find(".hpp") != std::string::npos);
                            std::vector<int> services_to_rebuild;
                            
                            if (service_id > 0) {
                                services_to_rebuild.push_back(service_id);
                            } else if (is_header) {
                                // Rebuild all C++ services when a shared header changes
                                std::cout << "  â„¹ï¸  Header file changed - rebuilding all services that may depend on it...\n\n";
                                for (const auto& [svc_name, svc_id] : service_map) {
                                    services_to_rebuild.push_back(svc_id);
                                }
                            }
                            
                            for (int svc_id : services_to_rebuild) {
                                // Check if service is running
                                bool was_running = false;
                                std::string service_name;
                                {
                                    std::lock_guard<std::mutex> lock(mutex_);
                                    if (services_.find(svc_id) != services_.end()) {
                                        was_running = services_[svc_id].running;
                                        service_name = services_[svc_id].name;
                                    }
                                }
                                
                                if (service_name.empty()) continue;
                                
                                std::cout << "  ğŸ”¨ Building: " << service_name << "...\n";
                                
                                // Rebuild the service
                                std::vector<std::string> build_output;
                                bool build_success = build_service(svc_id, service_name, build_output);
                                
                                if (build_success) {
                                    watchdog_rebuilds_++;
                                    std::cout << "     âœ“ Build successful\n";
                                    
                                    // Restart if it was running
                                    if (was_running) {
                                        watchdog_restarts_++;
                                        std::cout << "     ğŸ”„ Restarting service...\n";
                                        stop_service(svc_id);
                                        usleep(500000); // Wait 500ms
                                        start_service(svc_id);
                                        std::cout << "     âœ“ Service restarted\n\n";
                                    } else {
                                        std::cout << "     â„¹ï¸  Service was not running, not restarting\n\n";
                                    }
                                } else {
                                    std::cout << "     âœ— Build failed! Check output above\n\n";
                                }
                            }
                            
                            std::cout << "âœ“ Hot-reload complete\n\n";
                            
                            watched_files_mtimes_[filepath] = mtime;
                        }
                    } else {
                        // First time seeing this file
                        watched_files_mtimes_[filepath] = mtime;
                    }
                }
            }
        }
    }
    
    void read_service_outputs() {
        fd_set read_fds;
        struct timeval tv;
        char buffer[4096];
        
        while (running_) {
            FD_ZERO(&read_fds);
            int max_fd = 0;
            
            {
                std::lock_guard<std::mutex> lock(mutex_);
                // Check for dead processes and clean them up
                for (auto& [id, svc] : services_) {
                    if (svc.running && svc.pid > 0) {
                        if (!is_process_alive(svc.pid)) {
                            std::cout << "[ServiceManager] Service " << id << " (" << svc.name 
                                      << ") process died (PID " << svc.pid << ")" << std::endl;
                            svc.running = false;
                            svc.pid = -1;
                            if (svc.output_fd > 0) {
                                close(svc.output_fd);
                                svc.output_fd = -1;
                            }
                            svc.output_lines.push_back("=== SERVICE CRASHED OR EXITED ===");
                        }
                    }
                    
                    if (svc.running && svc.output_fd > 0) {
                        FD_SET(svc.output_fd, &read_fds);
                        max_fd = std::max(max_fd, svc.output_fd);
                    }
                }
            }
            
            if (max_fd == 0) {
                usleep(100000);
                continue;
            }
            
            tv.tv_sec = 0;
            tv.tv_usec = 100000;
            
            int result = select(max_fd + 1, &read_fds, nullptr, nullptr, &tv);
            if (result > 0) {
                std::lock_guard<std::mutex> lock(mutex_);
                for (auto& [id, svc] : services_) {
                    if (svc.running && svc.output_fd > 0 && FD_ISSET(svc.output_fd, &read_fds)) {
                        ssize_t n = read(svc.output_fd, buffer, sizeof(buffer) - 1);
                        if (n > 0) {
                            buffer[n] = '\0';
                            std::string output(buffer);
                            
                            // Split by newlines and add to output_lines
                            size_t start = 0;
                            size_t end = output.find('\n');
                            while (end != std::string::npos) {
                                std::string line = output.substr(start, end - start);
                                if (!line.empty()) {
                                    svc.output_lines.push_back(line);
                                    // Keep last 100 lines
                                    if (svc.output_lines.size() > 100) {
                                        svc.output_lines.erase(svc.output_lines.begin());
                                    }
                                }
                                start = end + 1;
                                end = output.find('\n', start);
                            }
                            // Add remaining part
                            if (start < output.length()) {
                                std::string line = output.substr(start);
                                if (!line.empty()) {
                                    svc.output_lines.push_back(line);
                                    if (svc.output_lines.size() > 100) {
                                        svc.output_lines.erase(svc.output_lines.begin());
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
public:
    ServiceManager() {
        watchdog_start_time_ = std::chrono::steady_clock::now();
        
        services_[1] = {"Frontend", "", 9000, -1, true, "MATLAB-Style Web UI (this process)", {}, -1, 0};
        services_[2] = {"Metrics Backend", "./services/build/metrics_backend_service 9001", 9001, -1, false, "System metrics API", {}, -1, 0};
        services_[3] = {"Account Service", "./services/build/account_service 9002", 9002, -1, false, "User account management", {}, -1, 0};
        services_[4] = {"Proxy Service", "./services/build/proxy_service 8080", 8080, -1, false, "Reverse proxy with caching & SSL", {}, -1, 0};
        services_[5] = {"Account Frontend", "cd ./frontends/account-frontend && bun run server.ts", 3000, -1, false, "Bun.js account UI", {}, -1, 0};
        services_[6] = {"Metrics Frontend", "", 3001, -1, false, "Metrics dashboard (TBD)", {}, -1, 0};
        services_[7] = {"Admin Frontend", "", 3002, -1, false, "Admin panel (TBD)", {}, -1, 0};
        
        // Start output reading thread
        output_reader_ = std::thread(&ServiceManager::read_service_outputs, this);
        
        // Start file watcher thread
        file_watcher_ = std::thread(&ServiceManager::watch_service_files, this);
        
        // Check if nginx is available
        use_nginx_ = is_nginx_installed();
        if (use_nginx_) {
            std::cout << "âœ“ nginx detected - service routing via nginx enabled\n";
            std::cout << "  Config directory: " << nginx_conf_dir_ << "\n";
            
            // Create nginx configs for all services
            for (auto& [id, svc] : services_) {
                if (id > 1 && svc.port > 0) { // Skip frontend (ID 1)
                    std::string config = generate_nginx_config(id, svc);
                    write_nginx_config(id, config);
                }
            }
            
            // Test and reload nginx
            if (!reload_nginx()) {
                std::cout << "âš ï¸  nginx reload failed - falling back to direct routing\n";
                use_nginx_ = false;
            }
        } else {
            std::cout << "  nginx not found - using direct service routing\n";
            std::cout << "  Install nginx with: brew install nginx (macOS) or apt-get install nginx (Linux)\n";
        }
        
        std::cout << "âœ“ Service file watcher enabled (Watchdog)\n";
        std::cout << "  Monitoring: All C++ services in services/ directory\n";
        std::cout << "  Watching: *.cpp, *.h, *.hpp files\n";
        std::cout << "  Features: Auto-rebuild and hot-restart on changes\n";
        std::cout << "  Check interval: 2 seconds\n\n";
    }
    
    ~ServiceManager() {
        running_ = false;
        if (output_reader_.joinable()) {
            output_reader_.join();
        }
        if (file_watcher_.joinable()) {
            file_watcher_.join();
        }
    }
    
    bool start_service(int id) {
        std::unique_lock<std::mutex> lock(mutex_);
        if (services_.find(id) == services_.end()) return false;
        if (id == 1) return true; // Frontend always running
        
        ServiceInfo& svc = services_[id];
        
        std::cout << "[ServiceManager] Starting service " << id << " (" << svc.name << ")\n";
        std::cout << "[ServiceManager] Command: " << svc.command << "\n";
        
        // Skip services without commands (not yet implemented)
        if (svc.command.empty()) {
            std::cout << "[ServiceManager] No command specified for service " << id << "\n";
            return false;
        }
        
        // Check if Bun is installed for frontend services (IDs 4-6)
        if (id >= 4 && id <= 6 && svc.command.find("bun") != std::string::npos) {
            if (!is_bun_installed()) {
                std::cout << "[ServiceManager] Bun.js not installed for service " << id << "\n";
                svc.output_lines.clear();
                svc.output_lines.push_back("\033[31mâœ— Bun.js is not installed!\033[0m");
                svc.output_lines.push_back("");
                svc.output_lines.push_back("To install Bun.js, run:");
                svc.output_lines.push_back("  curl -fsSL https://bun.sh/install | bash");
                svc.output_lines.push_back("");
                svc.output_lines.push_back("After installation, reload your shell:");
                svc.output_lines.push_back("  source ~/.zshrc  # or ~/.bashrc");
                svc.output_lines.push_back("");
                svc.output_lines.push_back("Then try starting the service again.");
                return false;
            }
        }
        
        if (svc.running) {
            // Double-check if process is actually alive
            if (svc.pid > 0 && !is_process_alive(svc.pid)) {
                std::cout << "[ServiceManager] Service " << id << " was marked running but process is dead, restarting...\n";
                svc.running = false;
                svc.pid = -1;
                if (svc.output_fd > 0) {
                    close(svc.output_fd);
                    svc.output_fd = -1;
                }
                // Continue to start the service
            } else {
                std::cout << "[ServiceManager] Service " << id << " already running\n";
                return true;
            }
        }
        
        // Create pipe for capturing output
        int pipefd[2];
        if (pipe(pipefd) == -1) {
            std::cout << "[ServiceManager] Failed to create pipe for service " << id << "\n";
            return false;
        }
        
        std::cout << "[ServiceManager] Pipe created, forking process...\n";
        
        pid_t pid = fork();
        if (pid == 0) {
            // Child process
            close(pipefd[0]); // Close read end
            dup2(pipefd[1], STDOUT_FILENO);
            dup2(pipefd[1], STDERR_FILENO);
            close(pipefd[1]);
            
            // Now all output goes to the pipe
            std::cout << "[Child] Starting in PID " << getpid() << std::endl;
            std::cout << "[Child] Command: " << svc.command << std::endl;
            
            char cwd[1024];
            if (getcwd(cwd, sizeof(cwd)) != nullptr) {
                std::cout << "[Child] Working directory: " << cwd << std::endl;
            }
            
            std::cout << "[Child] Executing via shell..." << std::endl;
            std::cout << "[Child] About to call: /bin/sh -c " << svc.command << std::endl;
            std::cout.flush();
            std::cerr.flush();
            
            setsid(); // Create new session
            execl("/bin/sh", "sh", "-c", svc.command.c_str(), nullptr);
            
            // If we get here, execl failed
            int exec_errno = errno;
            std::cerr << "[Child] FATAL: execl failed!" << std::endl;
            std::cerr << "[Child] errno: " << exec_errno << " (" << strerror(exec_errno) << ")" << std::endl;
            std::cerr << "[Child] Command was: " << svc.command << std::endl;
            std::cerr.flush();
            exit(127);
        } else if (pid > 0) {
            close(pipefd[1]); // Close write end
            
            // Make read end non-blocking
            int flags = fcntl(pipefd[0], F_GETFL, 0);
            fcntl(pipefd[0], F_SETFL, flags | O_NONBLOCK);
            
            svc.pid = pid;
            svc.output_fd = pipefd[0];
            svc.running = true;
            
            // Never clear output_lines - always preserve history
            if (!svc.output_lines.empty()) {
                svc.output_lines.push_back("");
                svc.output_lines.push_back("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
            }
            
            svc.output_lines.push_back("=== Service Starting ===");
            svc.output_lines.push_back("PID: " + std::to_string(pid));
            svc.output_lines.push_back("Command: " + svc.command);
            svc.output_lines.push_back("Output FD: " + std::to_string(pipefd[0]));
            svc.output_lines.push_back("=== Waiting for output ===");
            
            std::cout << "[ServiceManager] Service " << id << " started with PID " << pid 
                      << ", output_fd=" << pipefd[0] << "\n";
            
            // Read all available output (multiple times to catch everything)
            usleep(150000); // Give service more time to output
            
            bool port_conflict = false;
            std::string all_output;
            char early_buffer[4096];
            for (int attempt = 0; attempt < 5; attempt++) {
                ssize_t bytes_read = read(pipefd[0], early_buffer, sizeof(early_buffer) - 1);
                if (bytes_read > 0) {
                    early_buffer[bytes_read] = '\0';
                    std::string output(early_buffer);
                    all_output += output;
                    std::cout << "[ServiceManager] Output from service " << id << " (attempt " << attempt << "):\n" << output << "\n";
                    
                    // Check for port conflict
                    if (output.find("Failed to bind to port") != std::string::npos || 
                        output.find("Address already in use") != std::string::npos) {
                        port_conflict = true;
                    }
                    
                    // Add to output lines
                    std::istringstream iss(output);
                    std::string line;
                    while (std::getline(iss, line)) {
                        svc.output_lines.push_back(line);
                    }
                }
                
                // Check if more data is available
                fd_set read_fds;
                struct timeval tv = {0, 50000}; // 50ms timeout
                FD_ZERO(&read_fds);
                FD_SET(pipefd[0], &read_fds);
                int select_result = select(pipefd[0] + 1, &read_fds, nullptr, nullptr, &tv);
                if (select_result <= 0) break; // No more data
            }
            
            // Check if process crashed immediately
            int status;
            pid_t result = waitpid(pid, &status, WNOHANG);
            if (result > 0) {
                // Process exited
                int exit_code = WIFEXITED(status) ? WEXITSTATUS(status) : -1;
                std::cout << "[ServiceManager] Service " << id << " exited immediately!";
                if (WIFEXITED(status)) {
                    std::cout << " Exit code: " << exit_code;
                }
                if (WIFSIGNALED(status)) {
                    std::cout << " Killed by signal: " << WTERMSIG(status);
                }
                std::cout << "\n";
                
                svc.running = false;
                svc.pid = -1;
                close(pipefd[0]);
                svc.output_fd = -1;
                svc.output_lines.push_back("=== SERVICE FAILED TO START ===");
                if (WIFEXITED(status)) {
                    svc.output_lines.push_back("Exit code: " + std::to_string(exit_code));
                }
                
                // Check for port conflict and offer solutions
                if (port_conflict) {
                    // Find process using the port
                    std::string port_str = std::to_string(svc.port);
                    std::string cmd = "lsof -ti:" + port_str + " 2>/dev/null";
                    FILE* pipe = popen(cmd.c_str(), "r");
                    std::string existing_pid_str;
                    
                    if (pipe) {
                        char buffer[128];
                        if (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
                            existing_pid_str = buffer;
                            // Remove trailing newline
                            if (!existing_pid_str.empty() && existing_pid_str[existing_pid_str.length()-1] == '\n') {
                                existing_pid_str.erase(existing_pid_str.length()-1);
                            }
                        }
                        pclose(pipe);
                    }
                    
                    if (!existing_pid_str.empty()) {
                        // Get detailed process information
                        std::string process_name = "unknown";
                        std::string process_cmd = "";
                        std::string ps_cmd = "ps -p " + existing_pid_str + " -o comm= 2>/dev/null";
                        FILE* ps_pipe = popen(ps_cmd.c_str(), "r");
                        if (ps_pipe) {
                            char name_buf[256];
                            if (fgets(name_buf, sizeof(name_buf), ps_pipe) != nullptr) {
                                process_name = name_buf;
                                if (!process_name.empty() && process_name[process_name.length()-1] == '\n') {
                                    process_name.erase(process_name.length()-1);
                                }
                            }
                            pclose(ps_pipe);
                        }
                        
                        // Get full command line
                        std::string args_cmd = "ps -p " + existing_pid_str + " -o args= 2>/dev/null";
                        FILE* args_pipe = popen(args_cmd.c_str(), "r");
                        if (args_pipe) {
                            char args_buf[512];
                            if (fgets(args_buf, sizeof(args_buf), args_pipe) != nullptr) {
                                process_cmd = args_buf;
                                if (!process_cmd.empty() && process_cmd[process_cmd.length()-1] == '\n') {
                                    process_cmd.erase(process_cmd.length()-1);
                                }
                                // Truncate if too long
                                if (process_cmd.length() > 80) {
                                    process_cmd = process_cmd.substr(0, 77) + "...";
                                }
                            }
                            pclose(args_pipe);
                        }
                        
                        svc.output_lines.push_back("");
                        svc.output_lines.push_back("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
                        svc.output_lines.push_back("â•‘  âš ï¸  PORT CONFLICT DETECTED                                           â•‘");
                        svc.output_lines.push_back("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
                        svc.output_lines.push_back("");
                        svc.output_lines.push_back("Port " + port_str + " is already in use!");
                        svc.output_lines.push_back("");
                        svc.output_lines.push_back("Process Information:");
                        svc.output_lines.push_back("  PID:     " + existing_pid_str);
                        svc.output_lines.push_back("  Name:    " + process_name);
                        if (!process_cmd.empty()) {
                            svc.output_lines.push_back("  Command: " + process_cmd);
                        }
                        svc.output_lines.push_back("");
                        svc.output_lines.push_back("Options to resolve:");
                        svc.output_lines.push_back("");
                        svc.output_lines.push_back("1ï¸âƒ£  Kill the conflicting process:");
                        svc.output_lines.push_back("    kill " + existing_pid_str + "     (or use Kill button above)");
                        svc.output_lines.push_back("");
                        svc.output_lines.push_back("2ï¸âƒ£  Change this service's port:");
                        svc.output_lines.push_back("    â€¢ Edit the port field in the service table above");
                        svc.output_lines.push_back("    â€¢ Suggested alternative: " + std::to_string(svc.port + 10));
                        svc.output_lines.push_back("");
                        svc.output_lines.push_back("3ï¸âƒ£  Auto-assign a free port:");
                        svc.output_lines.push_back("    â€¢ Click 'Auto-Port' button (if available)");
                        svc.output_lines.push_back("");
                        svc.output_lines.push_back("After resolving, click START to retry.");
                        svc.output_lines.push_back("");
                        
                        std::cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
                        std::cout << "â•‘  âš ï¸  PORT CONFLICT: Service " << id << " (" << svc.name << ")                  â•‘\n";
                        std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
                        std::cout << "â•‘  Port " << port_str << " is in use by:                                            â•‘\n";
                        std::cout << "â•‘    PID: " << existing_pid_str << std::string(58 - existing_pid_str.length(), ' ') << "â•‘\n";
                        std::cout << "â•‘    Process: " << process_name << std::string(53 - process_name.length(), ' ') << "â•‘\n";
                        std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
                        std::cout << "â•‘  Solutions:                                                           â•‘\n";
                        std::cout << "â•‘    1. kill " << existing_pid_str << "    (terminate the process)                        â•‘\n";
                        std::cout << "â•‘    2. Change port to " << (svc.port + 10) << "   (edit in UI)                          â•‘\n";
                        std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
                    }
                }
                
                // Exit code 127 means command not found - try to build it
                if (exit_code == 127 && (id == 2 || id == 3)) {
                    // Prevent infinite retry loop
                    if (svc.build_retry_count >= 2) {
                        svc.output_lines.push_back("");
                        svc.output_lines.push_back("=== ERROR: Build retry limit reached! ===");
                        svc.output_lines.push_back("The executable still cannot be found after building.");
                        svc.output_lines.push_back("Check the console output from the child process above.");
                        svc.output_lines.push_back("");
                        svc.build_retry_count = 0;
                        return false;
                    }
                    
                    svc.build_retry_count++;
                    svc.output_lines.push_back("");
                    svc.output_lines.push_back("=== Executable not found, attempting to build... (attempt " + std::to_string(svc.build_retry_count) + "/2) ===");
                    svc.output_lines.push_back("");
                    
                    // Unlock mutex before building (it can take time)
                    lock.unlock();
                    
                    std::vector<std::string> build_output;
                    bool build_success = build_service(id, svc.name, build_output);
                    
                    // Re-lock to update output
                    lock.lock();
                    
                    // Add build output to service console (don't limit during build)
                    for (const auto& line : build_output) {
                        svc.output_lines.push_back(line);
                    }
                    
                    if (build_success) {
                        svc.output_lines.push_back("");
                        svc.output_lines.push_back("=== Build successful! Retrying start... ===");
                        svc.output_lines.push_back("");
                        
                        // Release lock and retry (start_service will acquire its own lock)
                        lock.unlock();
                        bool retry_result = start_service(id);
                        
                        // Don't acquire lock again, start_service handled everything
                        return retry_result;
                    } else {
                        svc.output_lines.push_back("");
                        svc.output_lines.push_back("=== Build failed! ===");
                        svc.build_retry_count = 0;
                    }
                } else {
                    // Reset retry count on successful start
                    svc.build_retry_count = 0;
                }
                
                return false;
            }
            
            return true;
        }
        
        close(pipefd[0]);
        close(pipefd[1]);
        return false;
    }
    
    bool stop_service(int id) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (services_.find(id) == services_.end()) return false;
        if (id == 1) return false; // Can't stop frontend
        
        ServiceInfo& svc = services_[id];
        if (!svc.running) return true;
        
        if (svc.pid > 0) {
            kill(-svc.pid, SIGTERM); // Kill process group
            waitpid(svc.pid, nullptr, WNOHANG);
            svc.pid = -1;
        }
        
        if (svc.output_fd > 0) {
            close(svc.output_fd);
            svc.output_fd = -1;
        }
        
        svc.running = false;
        return true;
    }
    
    bool kill_service(int id) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (services_.find(id) == services_.end()) return false;
        if (id == 1) return false; // Can't kill frontend
        
        ServiceInfo& svc = services_[id];
        
        if (svc.pid > 0) {
            std::cout << "[ServiceManager] Force killing service " << id << " (PID " << svc.pid << ") with SIGKILL\n";
            kill(-svc.pid, SIGKILL); // Kill process group with SIGKILL (can't be caught)
            waitpid(svc.pid, nullptr, 0); // Wait for process to die
            svc.pid = -1;
            svc.output_lines.push_back("=== SERVICE FORCE KILLED ===");
        }
        
        if (svc.output_fd > 0) {
            close(svc.output_fd);
            svc.output_fd = -1;
        }
        
        svc.running = false;
        return true;
    }
    
    bool restart_service(int id) {
        stop_service(id);
        usleep(200000);
        return start_service(id);
    }
    
    std::map<int, ServiceInfo> get_services() {
        std::lock_guard<std::mutex> lock(mutex_);
        return services_;
    }
    
    std::vector<std::string> get_service_output(int id) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (services_.find(id) != services_.end()) {
            return services_[id].output_lines;
        }
        return {};
    }
    
    void update_service_port(int id, int new_port) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (services_.find(id) != services_.end()) {
            ServiceInfo& svc = services_[id];
            svc.port = new_port;
            
            // Update command with new port
            std::string& cmd = svc.command;
            size_t last_space = cmd.rfind(' ');
            if (last_space != std::string::npos) {
                cmd = cmd.substr(0, last_space + 1) + std::to_string(new_port);
            }
        }
    }
    
    int find_free_port(int start_port = 9000, int max_attempts = 100) {
        // Try to find a free port by attempting to bind
        for (int attempt = 0; attempt < max_attempts; attempt++) {
            int test_port = start_port + attempt;
            
            // Check with lsof first (faster)
            std::string cmd = "lsof -ti:" + std::to_string(test_port) + " 2>/dev/null";
            FILE* pipe = popen(cmd.c_str(), "r");
            if (pipe) {
                char buffer[128];
                bool in_use = (fgets(buffer, sizeof(buffer), pipe) != nullptr);
                pclose(pipe);
                
                if (!in_use) {
                    // Double-check by trying to bind
                    int sock = socket(AF_INET, SOCK_STREAM, 0);
                    if (sock >= 0) {
                        struct sockaddr_in addr;
                        addr.sin_family = AF_INET;
                        addr.sin_addr.s_addr = INADDR_ANY;
                        addr.sin_port = htons(test_port);
                        
                        int result = bind(sock, (struct sockaddr*)&addr, sizeof(addr));
                        close(sock);
                        
                        if (result == 0) {
                            return test_port; // Found a free port!
                        }
                    }
                }
            }
        }
        
        return -1; // No free port found
    }
    
    bool auto_assign_port(int id) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (services_.find(id) == services_.end()) return false;
        
        ServiceInfo& svc = services_[id];
        int original_port = svc.port;
        int free_port = find_free_port(original_port);
        
        if (free_port > 0) {
            svc.port = free_port;
            
            // Update command with new port
            std::string& cmd = svc.command;
            size_t last_space = cmd.rfind(' ');
            if (last_space != std::string::npos) {
                cmd = cmd.substr(0, last_space + 1) + std::to_string(free_port);
            }
            
            svc.output_lines.push_back("");
            svc.output_lines.push_back("âœ“ Auto-assigned free port: " + std::to_string(free_port));
            svc.output_lines.push_back("  (Original port " + std::to_string(original_port) + " was in use)");
            svc.output_lines.push_back("");
            
            std::cout << "[ServiceManager] Auto-assigned port " << free_port << " to service " << id << "\n";
            return true;
        }
        
        return false;
    }
    
    void stop_all() {
        for (auto& [id, svc] : services_) {
            if (id != 1) stop_service(id);
        }
    }
    
    // nginx configuration management
    std::string get_nginx_config(int service_id) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (!use_nginx_) {
            return "{\"error\": \"nginx routing not enabled\"}";
        }
        std::string config = read_nginx_config(service_id);
        if (config.empty()) {
            return "{\"error\": \"config file not found\"}";
        }
        return config;
    }
    
    bool update_nginx_config(int service_id, const std::string& config) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (!use_nginx_) {
            std::cerr << "[nginx] nginx routing not enabled\n";
            return false;
        }
        if (services_.find(service_id) == services_.end()) {
            std::cerr << "[nginx] Service " << service_id << " not found\n";
            return false;
        }
        
        if (!write_nginx_config(service_id, config)) {
            std::cerr << "[nginx] Failed to write config for service " << service_id << "\n";
            return false;
        }
        
        if (!reload_nginx()) {
            std::cerr << "[nginx] Failed to reload nginx after config update\n";
            return false;
        }
        
        std::cout << "[nginx] Config updated and reloaded for service " << service_id << "\n";
        return true;
    }
    
    bool reload_nginx_public() {
        std::lock_guard<std::mutex> lock(mutex_);
        if (!use_nginx_) {
            std::cerr << "[nginx] nginx routing not enabled\n";
            return false;
        }
        return reload_nginx();
    }
    
    bool is_nginx_enabled() {
        std::lock_guard<std::mutex> lock(mutex_);
        return use_nginx_;
    }
    
    std::string get_nginx_status() {
        std::lock_guard<std::mutex> lock(mutex_);
        std::string status = "{";
        status += "\"enabled\": " + std::string(use_nginx_ ? "true" : "false") + ",";
        status += "\"installed\": " + std::string(is_nginx_installed() ? "true" : "false") + ",";
        status += "\"config_dir\": \"" + nginx_conf_dir_ + "\",";
        status += "\"services\": [";
        
        bool first = true;
        for (const auto& [id, svc] : services_) {
            if (id > 1) { // Skip frontend
                if (!first) status += ",";
                status += "{\"id\": " + std::to_string(id);
                status += ", \"name\": \"" + svc.name + "\"";
                status += ", \"internal_port\": " + std::to_string(svc.port);
                status += ", \"nginx_port\": " + std::to_string(8000 + id);
                status += ", \"config_exists\": " + std::string(!read_nginx_config(id).empty() ? "true" : "false");
                status += "}";
                first = false;
            }
        }
        
        status += "]}";
        return status;
    }
    
    ServiceBuildInfo collect_build_info(int service_id) {
        ServiceBuildInfo info;
        info.service_id = service_id;
        
        // Determine executable path based on service
        std::string exec_name;
        if (service_id == 2) exec_name = "metrics_backend_service";
        else if (service_id == 3) exec_name = "account_service";
        else if (service_id == 4) exec_name = "proxy_service";
        else return info;
        
        info.executable_path = "./services/build/" + exec_name;
        std::string abs_path = "/Users/mehranghamaty/wkspace/ToolBox/services/build/" + exec_name;
        
        // Get file size and modification time
        struct stat st;
        if (stat(abs_path.c_str(), &st) == 0) {
            info.file_size = st.st_size;
            info.last_built = st.st_mtime;
        }
        
        // Get linked libraries using otool
        std::string cmd = "otool -L " + abs_path + " 2>/dev/null";
        FILE* pipe = popen(cmd.c_str(), "r");
        if (pipe) {
            char buffer[512];
            bool first_line = true;
            while (fgets(buffer, sizeof(buffer), pipe)) {
                if (first_line) { // Skip the first line (executable path)
                    first_line = false;
                    continue;
                }
                
                std::string line(buffer);
                // Parse line format: "\t/path/to/lib.dylib (compatibility version X, current version Y)"
                size_t tab_pos = line.find('\t');
                size_t paren_pos = line.find('(');
                if (tab_pos != std::string::npos && paren_pos != std::string::npos) {
                    std::string lib_path = line.substr(tab_pos + 1, paren_pos - tab_pos - 2);
                    
                    LibraryInfo lib;
                    lib.path = lib_path;
                    
                    // Extract library name from path
                    size_t slash_pos = lib_path.rfind('/');
                    lib.name = (slash_pos != std::string::npos) ? lib_path.substr(slash_pos + 1) : lib_path;
                    
                    // Extract version if present
                    size_t current_pos = line.find("current version");
                    if (current_pos != std::string::npos) {
                        size_t ver_start = current_pos + 16; // "current version "
                        size_t ver_end = line.find(')', ver_start);
                        if (ver_end != std::string::npos) {
                            lib.version = line.substr(ver_start, ver_end - ver_start);
                        }
                    }
                    
                    info.linked_libraries.push_back(lib);
                }
            }
            pclose(pipe);
        }
        
        // Get source files for this service
        std::string src_path = "/Users/mehranghamaty/wkspace/ToolBox/services/" + exec_name + ".cpp";
        info.source_files.push_back(src_path);
        
        return info;
    }
    
    std::vector<SharedLibraryInfo> scan_shared_libraries() {
        std::vector<SharedLibraryInfo> libraries;
        
        // Scan build/src directory recursively for .so and .dylib files
        std::string build_src = "/Users/mehranghamaty/wkspace/ToolBox/build/src";
        std::string cmd = "find " + build_src + " -type f \\( -name '*.so' -o -name '*.dylib' \\) 2>/dev/null";
        
        FILE* pipe = popen(cmd.c_str(), "r");
        if (pipe) {
            char buffer[1024];
            while (fgets(buffer, sizeof(buffer), pipe)) {
                std::string lib_path(buffer);
                lib_path.erase(lib_path.find_last_not_of(" \n\r\t") + 1);
                
                SharedLibraryInfo lib_info;
                lib_info.path = lib_path;
                
                // Extract library name from path
                size_t last_slash = lib_path.rfind('/');
                lib_info.name = (last_slash != std::string::npos) ? lib_path.substr(last_slash + 1) : lib_path;
                
                // Get file stats
                struct stat st;
                if (stat(lib_path.c_str(), &st) == 0) {
                    lib_info.file_size = st.st_size;
                    lib_info.last_modified = st.st_mtime;
                }
                
                // Determine make target name from path
                // e.g., build/libraries/src/cache/libcache.dylib -> cache_server or cache
                std::string relative_path = lib_path;
                size_t src_pos = relative_path.find("/libraries/src/");
                if (src_pos != std::string::npos) {
                    relative_path = relative_path.substr(src_pos + 14); // Skip "/libraries/src/"
                    size_t first_slash = relative_path.find('/');
                    if (first_slash != std::string::npos) {
                        lib_info.target_name = relative_path.substr(0, first_slash);
                    }
                }
                
                // Remove lib prefix and extension for cleaner target name
                std::string clean_name = lib_info.name;
                if (clean_name.substr(0, 3) == "lib") {
                    clean_name = clean_name.substr(3);
                }
                size_t dot_pos = clean_name.find('.');
                if (dot_pos != std::string::npos) {
                    clean_name = clean_name.substr(0, dot_pos);
                }
                
                if (lib_info.target_name.empty()) {
                    lib_info.target_name = clean_name;
                }
                
                // Generate make command
                lib_info.make_command = "cmake --build build --target " + lib_info.target_name + " -j8";
                
                libraries.push_back(lib_info);
            }
            pclose(pipe);
        }
        
        return libraries;
    }
    
    bool rebuild_library(const std::string& target_name) {
        std::string cmd = "cd /Users/mehranghamaty/wkspace/ToolBox && cmake --build build --target " + target_name + " -j8 2>&1";
        FILE* pipe = popen(cmd.c_str(), "r");
        if (!pipe) return false;
        
        char buffer[256];
        bool success = true;
        while (fgets(buffer, sizeof(buffer), pipe)) {
            std::string line(buffer);
            if (line.find("error:") != std::string::npos || 
                line.find("Error ") != std::string::npos) {
                success = false;
            }
        }
        
        int exit_code = pclose(pipe);
        return (exit_code == 0 && success);
    }
    
    std::string get_watchdog_status() {
        std::lock_guard<std::mutex> lock(mutex_);
        
        auto now = std::chrono::steady_clock::now();
        auto uptime = std::chrono::duration_cast<std::chrono::seconds>(now - watchdog_start_time_).count();
        
        std::ostringstream json;
        json << "{";
        json << "\"enabled\": true,";
        json << "\"uptime_seconds\": " << uptime << ",";
        json << "\"total_checks\": " << watchdog_checks_ << ",";
        json << "\"total_rebuilds\": " << watchdog_rebuilds_ << ",";
        json << "\"total_restarts\": " << watchdog_restarts_ << ",";
        json << "\"check_interval_seconds\": 2,";
        json << "\"watched_files_count\": " << watched_files_list_.size() << ",";
        json << "\"watched_files\": [";
        
        bool first = true;
        for (const auto& file_info : watched_files_list_) {
            if (!first) json << ",";
            json << "{";
            json << "\"path\": \"" << file_info.filepath << "\",";
            json << "\"last_modified\": " << file_info.last_modified << ",";
            json << "\"last_checked\": " << file_info.last_checked << ",";
            json << "\"is_header\": " << (file_info.is_header ? "true" : "false") << ",";
            json << "\"associated_services\": [";
            for (size_t i = 0; i < file_info.associated_services.size(); i++) {
                if (i > 0) json << ",";
                json << file_info.associated_services[i];
            }
            json << "]";
            json << "}";
            first = false;
        }
        
        json << "],";
        json << "\"monitored_services\": [";
        
        first = true;
        for (const auto& [id, svc] : services_) {
            if (id == 2 || id == 3 || id == 4) { // C++ services
                if (!first) json << ",";
                json << "{";
                json << "\"id\": " << id << ",";
                json << "\"name\": \"" << svc.name << "\",";
                json << "\"running\": " << (svc.running ? "true" : "false");
                json << "}";
                first = false;
            }
        }
        
        json << "],";
        
        // Collect and include build information for each service
        json << "\"build_info\": [";
        first = true;
        for (int service_id : {2, 3, 4}) {
            ServiceBuildInfo build_info = collect_build_info(service_id);
            if (!build_info.executable_path.empty()) {
                if (!first) json << ",";
                json << "{";
                json << "\"service_id\": " << build_info.service_id << ",";
                json << "\"executable\": \"" << build_info.executable_path << "\",";
                json << "\"file_size\": " << build_info.file_size << ",";
                json << "\"last_built\": " << build_info.last_built << ",";
                json << "\"source_files\": [";
                for (size_t i = 0; i < build_info.source_files.size(); i++) {
                    if (i > 0) json << ",";
                    json << "\"" << build_info.source_files[i] << "\"";
                }
                json << "],";
                json << "\"linked_libraries\": [";
                for (size_t i = 0; i < build_info.linked_libraries.size(); i++) {
                    if (i > 0) json << ",";
                    json << "{";
                    json << "\"name\": \"" << build_info.linked_libraries[i].name << "\",";
                    json << "\"path\": \"" << build_info.linked_libraries[i].path << "\",";
                    json << "\"version\": \"" << build_info.linked_libraries[i].version << "\"";
                    json << "}";
                }
                json << "]";
                json << "}";
                first = false;
            }
        }
        json << "]";
        
        json << "}";
        
        return json.str();
    }
    
    bool trigger_rebuild(int service_id) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (services_.find(service_id) == services_.end()) return false;
        
        bool was_running = services_[service_id].running;
        std::string service_name = services_[service_id].name;
        
        std::vector<std::string> build_output;
        bool build_success = build_service(service_id, service_name, build_output);
        
        if (build_success && was_running) {
            stop_service(service_id);
            usleep(500000);
            start_service(service_id);
        }
        
        return build_success;
    }
};

class MATLABStyleUI {
public:
    MATLABStyleUI(int port, AuthSystem* auth_system, RequestLogger* logger, ServiceManager* service_manager, bool enable_hot_reload = true) 
        : port_(port), auth_system_(auth_system), logger_(logger), service_manager_(service_manager), running_(false), url_shortener_(), 
          enable_hot_reload_(enable_hot_reload) {
        std::cout << "ğŸ”¥ Hot-reload: " << (enable_hot_reload ? "ENABLED" : "DISABLED") << "\n";
    }
    
    void start() {
        running_ = true;
        
        server_fd_ = socket(AF_INET, SOCK_STREAM, 0);
        if (server_fd_ < 0) {
            std::cerr << "âœ— Failed to create socket\n";
            return;
        }
        
        int opt = 1;
        setsockopt(server_fd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
        
        sockaddr_in address{};
        address.sin_family = AF_INET;
        address.sin_addr.s_addr = INADDR_ANY;
        address.sin_port = htons(port_);
        
        if (bind(server_fd_, (struct sockaddr*)&address, sizeof(address)) < 0) {
            std::cerr << "âœ— Failed to bind to port " << port_ << " (already in use?)\n";
            close(server_fd_);
            return;
        }
        
        listen(server_fd_, 10);
        
        std::cout << "âœ“ MATLAB-Style App Launcher running on http://localhost:" << port_ << "\n";
        std::cout << "âœ“ Request logging enabled\n";
        std::cout << "âœ“ Thread-per-request mode\n" << std::flush;
        
        while (running_) {
            sockaddr_in client_addr{};
            socklen_t addr_len = sizeof(client_addr);
            int client_fd = accept(server_fd_, (struct sockaddr*)&client_addr, &addr_len);
            if (client_fd < 0) continue;
            
            // Handle each request in a separate thread to avoid blocking
            std::thread([this, client_fd]() {
                handle_request(client_fd);
                close(client_fd);
            }).detach();
        }
    }
    
private:
    int port_;
    int server_fd_;
    bool running_;
    AuthSystem* auth_system_;
    RequestLogger* logger_;
    ServiceManager* service_manager_;
    std::map<std::string, std::string> session_cache_;
    services::URLShortener url_shortener_;
    services::SystemMonitor system_monitor_;
    services::ServiceBreaker service_breaker_;
    bool enable_hot_reload_;
    std::map<std::string, std::pair<std::string, time_t>> html_cache_; // path -> (content, mtime)
    
    void handle_request(int client_fd) {
        char buffer[16384] = {0};
        ssize_t bytes_read = read(client_fd, buffer, sizeof(buffer) - 1);
        
        if (bytes_read <= 0) return;
        
        std::string request(buffer, bytes_read);
        
        // Check if we need to read more for POST body
        size_t content_length = 0;
        size_t cl_pos = request.find("Content-Length:");
        if (cl_pos != std::string::npos) {
            size_t cl_start = cl_pos + 15;
            size_t cl_end = request.find("\r\n", cl_start);
            std::string cl_str = request.substr(cl_start, cl_end - cl_start);
            // Trim whitespace
            size_t first = cl_str.find_first_not_of(" \t");
            size_t last = cl_str.find_last_not_of(" \t\r\n");
            if (first != std::string::npos && last != std::string::npos) {
                cl_str = cl_str.substr(first, last - first + 1);
                content_length = std::stoul(cl_str);
            }
        }
        
        // Check if we have the full body
        size_t header_end = request.find("\r\n\r\n");
        if (header_end != std::string::npos && content_length > 0) {
            size_t body_start = header_end + 4;
            size_t body_received = bytes_read - body_start;
            
            // Read more if needed
            while (body_received < content_length && bytes_read < (ssize_t)sizeof(buffer) - 1) {
                ssize_t more = read(client_fd, buffer + bytes_read, sizeof(buffer) - bytes_read - 1);
                if (more <= 0) break;
                bytes_read += more;
                body_received += more;
            }
            request = std::string(buffer, bytes_read);
        }
        
        // Parse request
        size_t method_end = request.find(" ");
        std::string method = request.substr(0, method_end);
        size_t path_start = method_end + 1;
        size_t path_end = request.find(" ", path_start);
        std::string path = request.substr(path_start, path_end - path_start);
        
        // Log incoming request to logger (not stdout)
        if (logger_) {
            logger_->log_request(method, path, std::this_thread::get_id());
        }
        
        size_t query_pos = path.find('?');
        std::string query;
        if (query_pos != std::string::npos) {
            query = path.substr(query_pos + 1);
            path = path.substr(0, query_pos);
        }
        
        std::string response;
        
        // Route handling - Passwordless mode
        if (path == "/" || path == "/login") {
            response = generate_app_launcher("");
        } else if (path == "/app/cache") {
            response = generate_cache_app("");
        } else if (path == "/app/dfs") {
            response = generate_dfs_app("");
        } else if (path == "/app/mail") {
            response = generate_mail_app("");
        } else if (path == "/app/ml") {
            response = generate_ml_app("");
        } else if (path == "/app/security") {
            response = generate_security_app("");
        } else if (path == "/app/dns") {
            response = generate_dns_app("");
        } else if (path == "/app/proxy") {
            response = generate_proxy_app("");
        } else if (path == "/app/urlshort") {
            response = generate_url_shortener_app("");
        } else if (path == "/app/monitor") {
            response = generate_system_monitor_app("");
        } else if (path == "/app/breaker") {
            response = generate_service_breaker_app("");
        } else if (path == "/app/frontends") {
            response = generate_frontends_manager("");
        } else if (path == "/app/manager" || path == "/manager") {
            // Try multiple possible paths for the HTML file
            std::vector<std::string> possible_paths = {
                "config/resources/html/service_manager.html",
                "../config/resources/html/service_manager.html",
                "../../config/resources/html/service_manager.html",
                "config/resources/html/service_manager.html",
                "../config/resources/html/service_manager.html"
            };
            
            for (const auto& html_path : possible_paths) {
                response = load_html_with_reload(html_path);
                if (!response.empty()) break;
            }
            
            if (response.empty()) {
                response = R"(<!DOCTYPE html>
<html><head><title>Service Manager</title></head><body>
<h1>Service Manager Error</h1>
<p>Failed to load service_manager.html</p>
<p>Tried paths:</p><ul>)";
                for (const auto& p : possible_paths) {
                    response += "<li>" + p + "</li>";
                }
                response += "</ul><a href='/'>Back to Home</a></body></html>";
            }
        } else if (path == "/admin") {
            response = generate_admin_panel("");
        } else if (path == "/account") {
            response = generate_account_management("");
        } else if (path == "/api/frontends/list" && request.find("GET") != std::string::npos) {
            // List existing frontends
            response = list_frontends_json();
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/frontends/create" && request.find("POST") != std::string::npos) {
            // Create new frontend
            std::string post_data = extract_post_data(request);
            response = create_frontend_boilerplate(post_data);
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/create_user" && request.find("POST") != std::string::npos) {
            // Handle user creation
            std::string post_data = extract_post_data(request);
            std::map<std::string, std::string> params;
            std::istringstream ss(post_data);
            std::string pair;
            while (std::getline(ss, pair, '&')) {
                size_t eq = pair.find('=');
                if (eq != std::string::npos) {
                    std::string key = pair.substr(0, eq);
                    std::string value = url_decode(pair.substr(eq + 1));
                    params[key] = value;
                }
            }
            
            if (!params["username"].empty() && !params["password"].empty()) {
                UserRole role = params["role"] == "admin" ? UserRole::ADMIN : UserRole::USER;
                bool success = auth_system_->create_user(params["username"], params["password"], 
                                                         params["email"], role);
                std::string message = success ? "User created successfully" : "Failed to create user";
                response = "HTTP/1.1 302 Found\r\nLocation: /admin?msg=" + message + "\r\n\r\n";
                write(client_fd, response.c_str(), response.length());
                return;
            }
            response = generate_admin_panel("");
        } else if (path == "/api/start_account_server") {
            // Simulate starting account server
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"status\":\"success\",\"message\":\"Account server started on port 8888\"}";
            write(client_fd, response.c_str(), response.length());
            std::cout << "\nâœ“ Account server started on port 8888\n";
            return;
        } else if (path == "/api/shorten" && request.find("POST") != std::string::npos) {
            // Handle URL shortening
            std::string post_data = extract_post_data(request);
            std::map<std::string, std::string> params;
            std::istringstream ss(post_data);
            std::string pair;
            while (std::getline(ss, pair, '&')) {
                size_t eq = pair.find('=');
                if (eq != std::string::npos) {
                    std::string key = pair.substr(0, eq);
                    std::string value = url_decode(pair.substr(eq + 1));
                    params[key] = value;
                }
            }
            
            std::string short_code = url_shortener_.shorten_url(params["url"], params["custom"]);
            if (!short_code.empty()) {
                response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"status\":\"success\",\"short_code\":\"" + short_code + "\",\"short_url\":\"http://localhost:9000/s/" + short_code + "\"}";
            } else {
                response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"status\":\"error\",\"message\":\"Invalid URL or custom code already taken\"}";
            }
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path.substr(0, 3) == "/s/") {
            // Redirect short URL
            std::string short_code = path.substr(3);
            std::string original_url = url_shortener_.resolve_url(short_code);
            if (!original_url.empty()) {
                response = "HTTP/1.1 302 Found\r\nLocation: " + original_url + "\r\n\r\n";
            } else {
                response = "HTTP/1.1 404 Not Found\r\nContent-Type: text/html\r\n\r\n<h1>404 - Short URL not found</h1>";
            }
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/service/start" && request.find("POST") != std::string::npos) {
            // Handle service start
            std::string post_data = extract_post_data(request);
            std::map<std::string, std::string> params = parse_json_body(post_data);
            
            int service_id = std::stoi(params["service_id"]);
            
            // Check if custom port is provided
            if (params.find("port") != params.end()) {
                int custom_port = std::stoi(params["port"]);
                service_manager_->update_service_port(service_id, custom_port);
            }
            
            bool success = service_manager_->start_service(service_id);
            
            std::string json_response = success ? 
                "{\"success\":true,\"message\":\"Service started\"}" :
                "{\"success\":false,\"message\":\"Failed to start service\"}";
            
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json_response;
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/service/stop" && request.find("POST") != std::string::npos) {
            // Handle service stop
            std::string post_data = extract_post_data(request);
            std::map<std::string, std::string> params = parse_json_body(post_data);
            
            int service_id = std::stoi(params["service_id"]);
            bool success = service_manager_->stop_service(service_id);
            
            std::string json_response = success ? 
                "{\"success\":true,\"message\":\"Service stopped\"}" :
                "{\"success\":false,\"message\":\"Failed to stop service\"}";
            
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json_response;
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/service/kill" && request.find("POST") != std::string::npos) {
            // Handle service force kill
            std::string post_data = extract_post_data(request);
            std::map<std::string, std::string> params = parse_json_body(post_data);
            
            int service_id = std::stoi(params["service_id"]);
            bool success = service_manager_->kill_service(service_id);
            
            std::string json_response = success ? 
                "{\"success\":true,\"message\":\"Service killed\"}" :
                "{\"success\":false,\"message\":\"Failed to kill service\"}";
            
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json_response;
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/service/autoport" && request.find("POST") != std::string::npos) {
            // Auto-assign a free port to a service
            std::string post_data = extract_post_data(request);
            std::map<std::string, std::string> params = parse_json_body(post_data);
            
            int service_id = std::stoi(params["service_id"]);
            bool success = service_manager_->auto_assign_port(service_id);
            
            std::string json_response = success ? 
                "{\"success\":true,\"message\":\"Port auto-assigned successfully\"}" :
                "{\"success\":false,\"message\":\"Failed to find a free port\"}";
            
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json_response;
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path.rfind("/api/service/output", 0) == 0 && request.find("GET") != std::string::npos) {
            // Handle service output request - extract id parameter
            size_t id_pos = path.find("id=");
            if (id_pos != std::string::npos) {
                int service_id = std::stoi(path.substr(id_pos + 3));
                auto output_lines = service_manager_->get_service_output(service_id);
                
                std::stringstream json;
                json << "{\"lines\":[";
                bool first = true;
                for (const auto& line : output_lines) {
                    if (!first) json << ",";
                    first = false;
                    // Escape JSON special characters
                    std::string escaped = line;
                    size_t pos = 0;
                    while ((pos = escaped.find('"', pos)) != std::string::npos) {
                        escaped.replace(pos, 1, "\\\"");
                        pos += 2;
                    }
                    pos = 0;
                    while ((pos = escaped.find('\\', pos)) != std::string::npos) {
                        if (escaped[pos+1] != '"') {  // Don't double-escape
                            escaped.replace(pos, 1, "\\\\");
                            pos += 2;
                        } else {
                            pos += 2;
                        }
                    }
                    pos = 0;
                    while ((pos = escaped.find('\n', pos)) != std::string::npos) {
                        escaped.replace(pos, 1, "\\n");
                        pos += 2;
                    }
                    json << "\"" << escaped << "\"";
                }
                json << "]}";
                
                response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json.str();
            } else {
                response = "HTTP/1.1 400 Bad Request\r\nContent-Type: application/json\r\n\r\n{\"error\":\"Missing id parameter\"}";
            }
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path.rfind("/api/service/console", 0) == 0 && request.find("GET") != std::string::npos) {
            // Handle service console HTML view - extract id parameter
            size_t id_pos = path.find("id=");
            if (id_pos != std::string::npos) {
                int service_id = std::stoi(path.substr(id_pos + 3));
                auto output_lines = service_manager_->get_service_output(service_id);
                auto services = service_manager_->get_services();
                std::string service_name = "Unknown Service";
                if (services.find(service_id) != services.end()) {
                    service_name = services[service_id].name;
                }
                
                std::stringstream html;
                html << R"(<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="1">
    <title>)" << service_name << R"( Console</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0d1117;
            color: #e0e0e0;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
        }
        .header {
            color: #a78bfa;
            padding: 10px;
            border-bottom: 1px solid #333;
            margin-bottom: 10px;
            font-weight: bold;
        }
        .line {
            padding: 2px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .empty {
            color: #666;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }
        .stats {
            color: #666;
            font-size: 11px;
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid #333;
        }
    </style>
</head>
<body>
    <div class="header">)" << service_name << R"( (ID: )" << service_id << R"()</div>)";
                
                if (output_lines.empty()) {
                    html << R"(<div class="empty">No output captured yet. Service may need to be started or may not be producing output.</div>)";
                } else {
                    for (const auto& line : output_lines) {
                        html << "<div class=\"line\">";
                        // HTML escape
                        for (char c : line) {
                            if (c == '<') html << "&lt;";
                            else if (c == '>') html << "&gt;";
                            else if (c == '&') html << "&amp;";
                            else if (c == '"') html << "&quot;";
                            else html << c;
                        }
                        html << "</div>\n";
                    }
                }
                
                html << R"(<div class="stats">Lines: )" << output_lines.size() 
                     << R"( | Auto-refresh: 1s | Last update: )" << std::time(nullptr) 
                     << R"(</div>
</body>
</html>)";
                
                std::string body = html.str();
                response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nCache-Control: no-cache\r\nContent-Length: " 
                          + std::to_string(body.length()) + "\r\n\r\n" + body;
            } else {
                response = "HTTP/1.1 400 Bad Request\r\nContent-Type: text/plain\r\n\r\nMissing id parameter";
            }
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/service/setport" && request.find("POST") != std::string::npos) {
            // Handle service port change
            std::string post_data = extract_post_data(request);
            std::map<std::string, std::string> params;
            std::istringstream ss(post_data);
            std::string pair;
            while (std::getline(ss, pair, '&')) {
                size_t eq = pair.find('=');
                if (eq != std::string::npos) {
                    std::string key = pair.substr(0, eq);
                    std::string value = url_decode(pair.substr(eq + 1));
                    params[key] = value;
                }
            }
            
            int port = std::stoi(params["port"]);
            bool success = service_breaker_.set_port(params["service"], port);
            response = success ? 
                "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"status\":\"success\"}" :
                "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"status\":\"error\"}";
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/rebuild" && request.find("POST") != std::string::npos) {
            // Handle service rebuild request
            std::string post_data = extract_post_data(request);
            std::map<std::string, std::string> params = parse_json_body(post_data);
            
            int service_id = std::stoi(params["service_id"]);
            std::string target_name;
            bool is_service = false;  // Services are built in services/ directory
            
            // Map service ID to build target
            if (service_id == 1) {
                // Frontend - this process, no rebuild needed
                response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n"
                          "{\"success\":false,\"message\":\"Frontend is part of matlab_platform_demo. Rebuild that instead.\"}";
                write(client_fd, response.c_str(), response.length());
                return;
            }
            else if (service_id == 2) {
                target_name = "metrics_backend_service";
                is_service = true;
            }
            else if (service_id == 3) {
                target_name = "account_service";
                is_service = true;
            }
            else if (service_id == 4) {
                target_name = "proxy_service";
                is_service = true;
            }
            else if (service_id >= 5 && service_id <= 7) {
                // Frontend services (Bun.js, etc)
                response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n"
                          "{\"success\":false,\"message\":\"Frontend services don't need rebuilding (interpreted JS/TS)\"}";
                write(client_fd, response.c_str(), response.length());
                return;
            }
            else {
                response = "HTTP/1.1 400 Bad Request\r\nContent-Type: application/json\r\n\r\n"
                          "{\"success\":false,\"message\":\"Invalid service ID\"}";
                write(client_fd, response.c_str(), response.length());
                return;
            }
            
            // Execute cmake build command
            // Get the project root directory (parent of demos/)
            char cwd[1024];
            getcwd(cwd, sizeof(cwd));
            std::string project_root = std::string(cwd);
            
            // If we're in build/demos, go up two levels
            if (project_root.find("/build") != std::string::npos) {
                size_t build_pos = project_root.find("/build");
                project_root = project_root.substr(0, build_pos);
            }
            
            std::string build_cmd;
            if (is_service) {
                // Build in services/ subdirectory
                build_cmd = "cd " + project_root + "/services && cmake --build build --target " + target_name + " 2>&1";
            } else {
                // Build in main build directory
                build_cmd = "cd " + project_root + " && cmake --build build --target " + target_name + " 2>&1";
            }
            
            FILE* pipe = popen(build_cmd.c_str(), "r");
            if (!pipe) {
                response = "HTTP/1.1 500 Internal Server Error\r\nContent-Type: application/json\r\n\r\n"
                          "{\"success\":false,\"message\":\"Failed to start build process\"}";
                write(client_fd, response.c_str(), response.length());
                return;
            }
            
            // Read build output
            char buffer[256];
            std::string build_output;
            while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
                build_output += buffer;
            }
            int status = pclose(pipe);
            
            bool success = (status == 0);
            std::string message = success ? 
                "Build completed successfully for " + target_name :
                "Build failed for " + target_name + "\\n\\nOutput:\\n" + build_output.substr(0, 500);
            
            // Escape message for JSON
            std::string escaped_message;
            for (char c : message) {
                if (c == '"') escaped_message += "\\\"";
                else if (c == '\\') escaped_message += "\\\\";
                else if (c == '\n') escaped_message += "\\n";
                else if (c == '\r') escaped_message += "\\r";
                else if (c == '\t') escaped_message += "\\t";
                else escaped_message += c;
            }
            
            std::stringstream json;
            json << "{\"success\":" << (success ? "true" : "false") 
                 << ",\"message\":\"" << escaped_message << "\"}";
            
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json.str();
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/metrics") {
            // Return current system metrics as JSON
            system_monitor_.update();
            auto metrics = system_monitor_.get_metrics();
            
            std::stringstream json;
            json << std::fixed << std::setprecision(2);
            json << "{"
                 << "\"cpu_usage\":" << metrics.cpu_usage << ","
                 << "\"memory_usage\":" << metrics.memory_usage << ","
                 << "\"memory_used_mb\":" << metrics.memory_used_mb << ","
                 << "\"memory_total_mb\":" << metrics.memory_total_mb << ","
                 << "\"disk_usage\":" << metrics.disk_usage << ","
                 << "\"disk_used_gb\":" << metrics.disk_used_gb << ","
                 << "\"disk_total_gb\":" << metrics.disk_total_gb << ","
                 << "\"network_rx_mbps\":" << metrics.network_rx_mbps << ","
                 << "\"network_tx_mbps\":" << metrics.network_tx_mbps << ","
                 << "\"network_rx_bytes\":" << metrics.network_rx_bytes << ","
                 << "\"network_tx_bytes\":" << metrics.network_tx_bytes << ","
                 << "\"process_count\":" << metrics.process_count << ","
                 << "\"uptime\":\"" << metrics.uptime << "\","
                 << "\"timestamp\":\"" << metrics.timestamp << "\""
                 << "}";
            
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nCache-Control: no-cache\r\n\r\n" + json.str();
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/nginx/status" && request.find("GET") != std::string::npos) {
            // Get nginx routing status
            std::string status_json = service_manager_->get_nginx_status();
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nCache-Control: no-cache\r\n\r\n" + status_json;
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path.rfind("/api/nginx/config", 0) == 0 && request.find("GET") != std::string::npos) {
            // Get nginx config for a specific service - extract id parameter
            size_t id_pos = path.find("id=");
            if (id_pos != std::string::npos) {
                int service_id = std::stoi(path.substr(id_pos + 3));
                std::string config = service_manager_->get_nginx_config(service_id);
                
                // Return as JSON with config as string
                std::stringstream json;
                json << "{\"service_id\":" << service_id << ",\"config\":\"";
                
                // Escape config for JSON
                for (char c : config) {
                    if (c == '"') json << "\\\"";
                    else if (c == '\\') json << "\\\\";
                    else if (c == '\n') json << "\\n";
                    else if (c == '\r') json << "\\r";
                    else if (c == '\t') json << "\\t";
                    else json << c;
                }
                json << "\"}";
                
                response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json.str();
            } else {
                response = "HTTP/1.1 400 Bad Request\r\nContent-Type: application/json\r\n\r\n{\"error\":\"Missing id parameter\"}";
            }
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/nginx/config" && request.find("POST") != std::string::npos) {
            // Update nginx config for a service
            std::string post_data = extract_post_data(request);
            std::map<std::string, std::string> params = parse_json_body(post_data);
            
            int service_id = std::stoi(params["service_id"]);
            std::string config = params["config"];
            
            // Unescape config (it was sent as JSON string)
            std::string unescaped_config;
            for (size_t i = 0; i < config.length(); i++) {
                if (config[i] == '\\' && i + 1 < config.length()) {
                    if (config[i+1] == 'n') { unescaped_config += '\n'; i++; }
                    else if (config[i+1] == 'r') { unescaped_config += '\r'; i++; }
                    else if (config[i+1] == 't') { unescaped_config += '\t'; i++; }
                    else if (config[i+1] == '\\') { unescaped_config += '\\'; i++; }
                    else if (config[i+1] == '"') { unescaped_config += '"'; i++; }
                    else unescaped_config += config[i];
                } else {
                    unescaped_config += config[i];
                }
            }
            
            bool success = service_manager_->update_nginx_config(service_id, unescaped_config);
            
            std::string json_response = success ? 
                "{\"success\":true,\"message\":\"nginx config updated and reloaded\"}" :
                "{\"success\":false,\"message\":\"Failed to update nginx config\"}";
            
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json_response;
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/nginx/reload" && request.find("POST") != std::string::npos) {
            // Reload nginx
            bool success = service_manager_->reload_nginx_public();
            
            std::string json_response = success ? 
                "{\"success\":true,\"message\":\"nginx reloaded successfully\"}" :
                "{\"success\":false,\"message\":\"Failed to reload nginx\"}";
            
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json_response;
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/watchdog/status" && request.find("GET") != std::string::npos) {
            // Get watchdog/hot-recompile status
            std::string status_json = service_manager_->get_watchdog_status();
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nCache-Control: no-cache\r\n\r\n" + status_json;
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/watchdog/trigger" && request.find("POST") != std::string::npos) {
            // Manually trigger rebuild for a service
            std::string post_data = extract_post_data(request);
            std::map<std::string, std::string> params = parse_json_body(post_data);
            
            int service_id = std::stoi(params["service_id"]);
            bool success = service_manager_->trigger_rebuild(service_id);
            
            std::string json_response = success ? 
                "{\"success\":true,\"message\":\"Service rebuild triggered\"}" :
                "{\"success\":false,\"message\":\"Failed to rebuild service\"}";
            
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json_response;
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/libraries") {
            // Get all shared libraries
            auto libraries = service_manager_->scan_shared_libraries();
            std::ostringstream json;
            json << "{\"libraries\":[";
            
            bool first = true;
            for (const auto& lib : libraries) {
                if (!first) json << ",";
                json << "{";
                json << "\"name\":\"" << lib.name << "\",";
                json << "\"path\":\"" << lib.path << "\",";
                json << "\"target\":\"" << lib.target_name << "\",";
                json << "\"size\":" << lib.file_size << ",";
                json << "\"last_modified\":" << lib.last_modified << ",";
                json << "\"make_command\":\"" << lib.make_command << "\"";
                json << "}";
                first = false;
            }
            
            json << "]}";
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nCache-Control: no-cache\r\n\r\n" + json.str();
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/library/rebuild" && request.find("POST") != std::string::npos) {
            // Rebuild a specific library
            std::string post_data = extract_post_data(request);
            std::map<std::string, std::string> params = parse_json_body(post_data);
            
            std::string target = params["target"];
            bool success = service_manager_->rebuild_library(target);
            
            std::string json_response = success ? 
                "{\"success\":true,\"message\":\"Library rebuilt successfully\"}" :
                "{\"success\":false,\"message\":\"Failed to rebuild library\"}";
            
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json_response;
            write(client_fd, response.c_str(), response.length());
            return;
        } else if (path == "/api/services") {
            // Return all services as JSON
            auto services = service_manager_->get_services();
            std::stringstream json;
            json << "{";
            bool first = true;
            for (const auto& [id, svc] : services) {
                if (!first) json << ",";
                first = false;
                json << "\"" << id << "\":{";
                json << "\"name\":\"" << svc.name << "\",";
                json << "\"port\":" << svc.port << ",";
                json << "\"running\":" << (svc.running ? "true" : "false") << ",";
                json << "\"description\":\"" << svc.description << "\"";
                json << "}";
            }
            json << "}";
            
            response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nCache-Control: no-cache\r\n\r\n" + json.str();
            write(client_fd, response.c_str(), response.length());
            return;
        } else {
            response = generate_app_launcher("");
        }
        
        std::string http_response = 
            "HTTP/1.1 200 OK\r\n"
            "Content-Type: text/html; charset=utf-8\r\n"
            "Content-Length: " + std::to_string(response.length()) + "\r\n"
            "Connection: close\r\n"
            "\r\n" + response;
        
        write(client_fd, http_response.c_str(), http_response.length());
    }
    
    std::string extract_session_cookie(const std::string& request) {
        size_t cookie_pos = request.find("Cookie:");
        if (cookie_pos == std::string::npos) return "";
        
        size_t start = request.find("session_id=", cookie_pos);
        if (start == std::string::npos) return "";
        
        start += 11;  // length of "session_id="
        size_t end = request.find_first_of(";\r\n", start);
        if (end == std::string::npos) end = request.length();
        
        return request.substr(start, end - start);
    }
    
    std::string extract_post_data(const std::string& request) {
        std::cout << "\n[extract_post_data] Request length: " << request.length() << "\n";
        std::cout << "[extract_post_data] First 500 chars: " << request.substr(0, 500) << "\n";
        
        size_t pos = request.find("\r\n\r\n");
        if (pos == std::string::npos) {
            std::cout << "[extract_post_data] No \\r\\n\\r\\n found!\n";
            return "";
        }
        
        std::string body = request.substr(pos + 4);
        std::cout << "[extract_post_data] Body extracted: [" << body << "]\n";
        std::cout << "[extract_post_data] Body length: " << body.length() << "\n";
        return body;
    }
    
    std::string generate_frontends_manager(const std::string& session_id) {
        // Load from HTML file
        std::string html_path = "../config/resources/html/frontend_manager.html";
        std::string html = load_html_with_reload(html_path);
        
        // Fall back to basic message if file not found
        if (html.empty()) {
            html = "<!DOCTYPE html><html><head><title>Frontend Manager</title></head><body>";
            html += "<h1>Frontend Manager</h1><p>Loading from: " + html_path + "</p>";
            html += "<p>File not found. Please ensure the HTML file exists.</p>";
            html += "<a href=\"/\">Back to Apps</a></body></html>";
        }
        
        return html;
    }
    
    std::string url_decode(const std::string& str) {
        std::string result;
        for (size_t i = 0; i < str.length(); i++) {
            if (str[i] == '%' && i + 2 < str.length()) {
                int value;
                std::istringstream is(str.substr(i + 1, 2));
                if (is >> std::hex >> value) {
                    result += static_cast<char>(value);
                    i += 2;
                } else {
                    result += str[i];
                }
            } else if (str[i] == '+') {
                result += ' ';
            } else {
                result += str[i];
            }
        }
        return result;
    }
    
    std::map<std::string, std::string> parse_json_body(const std::string& json) {
        std::map<std::string, std::string> result;
        
        // Simple JSON parser for {"key":"value"} format
        size_t pos = 0;
        while ((pos = json.find("\"", pos)) != std::string::npos) {
            size_t key_start = pos + 1;
            size_t key_end = json.find("\"", key_start);
            if (key_end == std::string::npos) break;
            
            std::string key = json.substr(key_start, key_end - key_start);
            
            size_t colon = json.find(":", key_end);
            if (colon == std::string::npos) break;
            
            size_t value_start = json.find_first_not_of(" \\t", colon + 1);
            if (value_start == std::string::npos) break;
            
            std::string value;
            if (json[value_start] == '\"') {
                // String value
                value_start++;
                size_t value_end = json.find("\"", value_start);
                if (value_end == std::string::npos) break;
                value = json.substr(value_start, value_end - value_start);
                pos = value_end + 1;
            } else {
                // Number or other value
                size_t value_end = json.find_first_of(",}", value_start);
                if (value_end == std::string::npos) break;
                value = json.substr(value_start, value_end - value_start);
                // Trim whitespace
                size_t start = value.find_first_not_of(" \\t");
                size_t end = value.find_last_not_of(" \\t");
                if (start != std::string::npos && end != std::string::npos) {
                    value = value.substr(start, end - start + 1);
                }
                pos = value_end;
            }
            
            result[key] = value;
        }
        
        return result;
    }
    
    AuthResult handle_login(const std::string& post_data) {
        std::map<std::string, std::string> params;
        std::istringstream ss(post_data);
        std::string pair;
        
        std::cout << "Parsing form data...\n";
        while (std::getline(ss, pair, '&')) {
            size_t eq = pair.find('=');
            if (eq != std::string::npos) {
                std::string key = pair.substr(0, eq);
                std::string value = url_decode(pair.substr(eq + 1));
                params[key] = value;
                std::cout << "  " << key << " = [" << value << "] (length: " << value.length() << ")\n";
            }
        }
        
        std::cout << "\nAttempting login...\n";
        std::cout << "  Username: '" << params["username"] << "'\n";
        std::cout << "  Password: '" << params["password"] << "'\n";
        std::cout << "  Password length: " << params["password"].length() << "\n";
        
        auto result = auth_system_->login(params["username"], params["password"]);
        
        if (result.success) {
            std::cout << "âœ“ Login successful for user: " << params["username"] << "\n";
            std::cout << "  Session ID: " << result.session_id << "\n";
        } else {
            std::cout << "âœ— Login failed: " << result.message << "\n";
        }
        
        return result;
    }
    
    std::string load_html_with_reload(const std::string& file_path) {
        if (!enable_hot_reload_) {
            // Hot-reload disabled, check cache only
            auto it = html_cache_.find(file_path);
            if (it != html_cache_.end()) {
                return it->second.first;
            }
            return "";
        }
        
        // Check if file exists and get modification time
        struct stat file_stat;
        if (stat(file_path.c_str(), &file_stat) != 0) {
            // File doesn't exist, return cached or empty
            auto it = html_cache_.find(file_path);
            return (it != html_cache_.end()) ? it->second.first : "";
        }
        
        time_t mtime = file_stat.st_mtime;
        
        // Check if we have cached and if it's up to date
        auto it = html_cache_.find(file_path);
        if (it != html_cache_.end() && it->second.second >= mtime) {
            return it->second.first; // Cache is fresh
        }
        
        // Read file
        std::ifstream file(file_path);
        if (!file.is_open()) {
            std::cout << "âš ï¸  Failed to open: " << file_path << "\\n";
            return (it != html_cache_.end()) ? it->second.first : "";
        }
        
        std::string content((std::istreambuf_iterator<char>(file)),
                            std::istreambuf_iterator<char>());
        file.close();
        
        // Update cache
        html_cache_[file_path] = {content, mtime};
        
        // Alert with timestamp
        auto now = std::chrono::system_clock::now();
        auto now_c = std::chrono::system_clock::to_time_t(now);
        auto now_ms = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()) % 1000;
        char time_buf[32];
        std::strftime(time_buf, sizeof(time_buf), "%H:%M:%S", std::localtime(&now_c));
        
        std::cout << "\n";
        std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        std::cout << "â•‘  ğŸ”„ \033[1m\033[33mFILE CHANGE DETECTED\033[0m                                    â•‘\n";
        std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        std::cout << "â•‘  Time:     " << time_buf << "." << std::setfill('0') << std::setw(3) << now_ms.count() << "                                           â•‘\n";
        std::cout << "â•‘  File:     " << std::left << std::setw(50) << file_path.substr(file_path.find_last_of("/") + 1) << "â•‘\n";
        std::cout << "â•‘  Path:     " << std::left << std::setw(50) << file_path << "â•‘\n";
        std::cout << "â•‘  Status:   \033[32mâœ“ Reloaded\033[0m                                          â•‘\n";
        std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
        std::cout << "\n";
        
        return content;
    }
    
    std::string generate_login_page(const std::string& error = "") {
        ComponentBundler bundler;
        
        std::string error_html;
        if (!error.empty()) {
            error_html = "<div style=\"background: #fee; border: 1px solid #fcc; padding: 1rem; border-radius: 4px; margin-bottom: 1rem; color: #c33;\">" + error + "</div>";
        }
        
        return bundler
            .set_title("Login - MATLAB Style Platform")
            .add_global_style(R"(
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body {
                    font-family: Arial, Helvetica, sans-serif;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    min-height: 100vh;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                .login-container {
                    background: white;
                    padding: 3rem;
                    border-radius: 12px;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                    width: 400px;
                    max-width: 90%;
                }
                .logo {
                    text-align: center;
                    font-size: 2.5rem;
                    color: #667eea;
                    margin-bottom: 2rem;
                    font-weight: bold;
                }
                .login-form input {
                    width: 100%;
                    padding: 0.75rem;
                    margin-bottom: 1rem;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-size: 1rem;
                }
                .login-form button {
                    width: 100%;
                    padding: 0.75rem;
                    background: #667eea;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    font-size: 1rem;
                    cursor: pointer;
                    font-weight: bold;
                }
                .login-form button:hover {
                    background: #5568d3;
                }
                .hint {
                    text-align: center;
                    color: #666;
                    font-size: 0.9rem;
                    margin-top: 1rem;
                }
            )")
            .set_body_content(R"(
                <div class="login-container">
                    <div class="logo">ğŸ”¬ ToolBox Platform</div>
                    )" + error_html + R"(
                    <form class="login-form" method="POST" action="/api/login">
                        <input type="text" name="username" placeholder="Username" required>
                        <input type="password" name="password" placeholder="Password" required>
                        <button type="submit">Sign In</button>
                    </form>
                    <div class="hint">
                        Default: admin/admin123 or user/user123
                    </div>
                </div>
            )")
            .minify(true)
            .bundle();
    }
    
    std::string generate_app_launcher(const std::string& session_id) {
        std::string username = "Guest";
        std::string role = "User";
        
        // Try hot-reload from source file first
        std::string html_path = "../config/resources/html/app_launcher.html";
        std::string html = load_html_with_reload(html_path);
        
        // Fall back to embedded resource if hot-reload fails
        if (html.empty()) {
            html = resources::APP_LAUNCHER_HTML;
        }
        
        // Replace placeholders
        size_t pos = html.find("{{USERNAME}}");
        if (pos != std::string::npos) {
            html.replace(pos, 12, username);
        }
        pos = html.find("{{ROLE}}");
        if (pos != std::string::npos) {
            html.replace(pos, 8, role);
        }
        
        return html;
    }
    
    std::string generate_cache_app(const std::string& session_id) {
        std::string content = 
                "<h3>Cache Operations</h3>"
                "<form-input label=\"Key\" placeholder=\"my_key\"></form-input>"
                "<form-input label=\"Value\" placeholder=\"my_value\"></form-input>"
                "<form-input label=\"TTL seconds\" placeholder=\"3600\"></form-input>"
                "<app-button>Set Cache</app-button>"
                "<app-button>Get Cache</app-button>"
                "<app-button>Delete Cache</app-button>"
                "<h3 style=\"margin-top: 2rem;\">Statistics</h3>"
                "<progress-bar value=\"75\" max=\"100\"></progress-bar>"
                "<p>Cache Hit Rate: 75%</p>"
                "<progress-bar value=\"4096\" max=\"10000\"></progress-bar>"
                "<p>Memory Usage: 4096/10000 MB</p>";
        return generate_generic_app(session_id, "Cache Server", "ğŸ’¾", 
            "Manage high-performance distributed caching", content);
    }
    
    std::string generate_dfs_app(const std::string& session_id) {
        std::string content =
                "<h3>File Operations</h3>"
                "<form-input label=\"Filename\" placeholder=\"/path/to/file.txt\"></form-input>"
                "<form-input label=\"Content\" placeholder=\"File content...\"></form-input>"
                "<form-input label=\"Replication Factor\" placeholder=\"3\"></form-input>"
                "<app-button>Upload File</app-button>"
                "<app-button>Download File</app-button>"
                "<app-button>Delete File</app-button>"
                "<h3 style=\"margin-top: 2rem;\">Storage Nodes</h3>"
                "<data-table>"
                "    <tr slot=\"header\"><th>Node</th><th>Status</th><th>Storage</th></tr>"
                "    <tr><td>node-1</td><td>âœ“ Online</td><td>500 GB</td></tr>"
                "    <tr><td>node-2</td><td>âœ“ Online</td><td>500 GB</td></tr>"
                "    <tr><td>node-3</td><td>âœ“ Online</td><td>500 GB</td></tr>"
                "</data-table>";
        return generate_generic_app(session_id, "Distributed File System", "ğŸ“",
            "Manage distributed file storage and replication", content);
    }
    
    std::string generate_mail_app(const std::string& session_id) {
        std::string content =
                "<h3>Compose Email</h3>"
                "<form-input label=\"To\" placeholder=\"user@example.com\"></form-input>"
                "<form-input label=\"Subject\" placeholder=\"Subject\"></form-input>"
                "<form-input label=\"Message\" placeholder=\"Email body...\"></form-input>"
                "<app-button>Send Email</app-button>"
                "<h3 style=\"margin-top: 2rem;\">Inbox</h3>"
                "<data-table>"
                "    <tr slot=\"header\"><th>From</th><th>Subject</th><th>Date</th></tr>"
                "    <tr><td>admin@localhost</td><td>Welcome</td><td>Today</td></tr>"
                "    <tr><td>system@localhost</td><td>Alert</td><td>Yesterday</td></tr>"
                "</data-table>";
        return generate_generic_app(session_id, "Mail Server", "ğŸ“§",
            "SMTP/POP3 email server management", content);
    }
    
    std::string generate_ml_app(const std::string& session_id) {
        std::string content =
                "<h3>Model Selection</h3>"
                "<form-input label=\"Model\" placeholder=\"Select model...\"></form-input>"
                "<form-input label=\"Dataset\" placeholder=\"Select dataset...\"></form-input>"
                "<h3>Input Features</h3>"
                "<form-input label=\"Feature 1\" placeholder=\"0.5\"></form-input>"
                "<form-input label=\"Feature 2\" placeholder=\"1.2\"></form-input>"
                "<form-input label=\"Feature 3\" placeholder=\"-0.3\"></form-input>"
                "<app-button>Run Prediction</app-button>"
                "<h3 style=\"margin-top: 2rem;\">Model Performance</h3>"
                "<progress-bar value=\"92\" max=\"100\"></progress-bar>"
                "<p>Accuracy: 92%</p>";
        return generate_generic_app(session_id, "ML Model Server", "ğŸ¤–",
            "Machine learning model deployment and serving", content);
    }
    
    std::string generate_security_app(const std::string& session_id) {
        std::string content =
                "<h3>Scan Operations</h3>"
                "<form-input label=\"Content\" placeholder=\"Paste content to scan...\"></form-input>"
                "<app-button>Scan Content</app-button>"
                "<app-button>Scan File</app-button>"
                "<h3 style=\"margin-top: 2rem;\">Threat Statistics</h3>"
                "<progress-bar value=\"95\" max=\"100\"></progress-bar>"
                "<p>System Health: 95%</p>"
                "<data-table>"
                "    <tr slot=\"header\"><th>Type</th><th>Count</th><th>Status</th></tr>"
                "    <tr><td>Malware</td><td>0</td><td>âœ“ Clean</td></tr>"
                "    <tr><td>Suspicious</td><td>2</td><td>âš  Review</td></tr>"
                "</data-table>";
        return generate_generic_app(session_id, "Security Scanner", "ğŸ”’",
            "Malware detection and content security", content);
    }
    
    std::string generate_dns_app(const std::string& session_id) {
        std::string content =
                "<h3>DNS Lookup</h3>"
                "<form-input label=\"Domain\" placeholder=\"example.com\"></form-input>"
                "<app-button>Lookup</app-button>"
                "<h3 style=\"margin-top: 2rem;\">DNS Records</h3>"
                "<data-table>"
                "    <tr slot=\"header\"><th>Domain</th><th>Type</th><th>Value</th></tr>"
                "    <tr><td>localhost</td><td>A</td><td>127.0.0.1</td></tr>"
                "    <tr><td>api.local</td><td>A</td><td>192.168.1.100</td></tr>"
                "</data-table>";
        return generate_generic_app(session_id, "DNS Server", "ğŸŒ",
            "Domain name resolution service", content);
    }
    
    std::string generate_proxy_app(const std::string& session_id) {
        std::string content =
                "<h3>Proxy Configuration</h3>"
                "<form-input label=\"Target URL\" placeholder=\"http://backend:8080\"></form-input>"
                "<form-input label=\"Port\" placeholder=\"8081\"></form-input>"
                "<app-button>Start Proxy</app-button>"
                "<app-button>Stop Proxy</app-button>"
                "<h3 style=\"margin-top: 2rem;\">Traffic Statistics</h3>"
                "<progress-bar value=\"45\" max=\"100\"></progress-bar>"
                "<p>CPU Usage: 45%</p>"
                "<p>Requests/sec: 1250</p>";
        return generate_generic_app(session_id, "Proxy Server", "ğŸ”„",
            "HTTP/HTTPS proxy and load balancing", content);
    }
    
    std::string generate_url_shortener_app(const std::string& session_id) {
        auto all_urls = url_shortener_.get_all_urls();
        std::stringstream urls_table;
        
        for (const auto& [code, url_info] : all_urls) {
            urls_table << "<tr>"
                      << "<td><a href='/s/" << code << "' target='_blank'>" << code << "</a></td>"
                      << "<td style='max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;'>" 
                      << url_info.original_url << "</td>"
                      << "<td>" << url_info.click_count << "</td>"
                      << "<td>" << url_info.created_at << "</td>"
                      << "</tr>";
        }
        
        std::string content =
                "<h3>Shorten URL</h3>"
                "<form id='shortenForm' onsubmit='return shortenURL(event);' style='background: #f8f9fa; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;'>"
                "    <div style='margin-bottom: 1rem;'>"
                "        <label style='display: block; margin-bottom: 0.5rem; font-weight: bold;'>Long URL</label>"
                "        <input type='url' id='longUrl' required placeholder='https://example.com/very/long/url' "
                "               style='width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem;'>"
                "    </div>"
                "    <div style='margin-bottom: 1rem;'>"
                "        <label style='display: block; margin-bottom: 0.5rem; font-weight: bold;'>Custom Code (optional)</label>"
                "        <input type='text' id='customCode' placeholder='mylink' "
                "               style='width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem;'>"
                "    </div>"
                "    <button type='submit' style='background: #3498db; color: white; border: none; padding: 0.75rem 2rem; border-radius: 4px; cursor: pointer; font-size: 1rem;'>"
                "        ğŸ”— Shorten URL"
                "    </button>"
                "</form>"
                "<div id='result' style='display: none; background: #d4edda; border: 1px solid #c3e6cb; padding: 1rem; border-radius: 4px; margin-bottom: 2rem;'>"
                "    <strong>âœ“ URL Shortened!</strong><br>"
                "    <p style='margin-top: 0.5rem;'>Short URL: <a id='shortUrl' href='#' target='_blank' style='color: #155724; font-weight: bold;'></a></p>"
                "    <button onclick='copyToClipboard()' style='background: #28a745; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; margin-top: 0.5rem;'>"
                "        ğŸ“‹ Copy Link"
                "    </button>"
                "</div>"
                "<h3>Statistics</h3>"
                "<div style='background: white; padding: 1rem; border-radius: 8px; margin-bottom: 2rem;'>"
                "    <p><strong>Total URLs:</strong> " + std::to_string(url_shortener_.get_total_urls()) + "</p>"
                "    <p><strong>Total Clicks:</strong> " + std::to_string(url_shortener_.get_total_clicks()) + "</p>"
                "</div>"
                "<h3>Recent URLs</h3>"
                "<div style='background: white; padding: 1.5rem; border-radius: 8px; overflow-x: auto;'>"
                "    <table style='width: 100%; border-collapse: collapse;'>"
                "        <thead>"
                "            <tr style='background: #f8f9fa; border-bottom: 2px solid #dee2e6;'>"
                "                <th style='padding: 1rem; text-align: left;'>Code</th>"
                "                <th style='padding: 1rem; text-align: left;'>Original URL</th>"
                "                <th style='padding: 1rem; text-align: left;'>Clicks</th>"
                "                <th style='padding: 1rem; text-align: left;'>Created</th>"
                "            </tr>"
                "        </thead>"
                "        <tbody>" + urls_table.str() + "</tbody>"
                "    </table>"
                "</div>"
                "<script>"
                "function shortenURL(event) {"
                "    event.preventDefault();"
                "    const longUrl = document.getElementById('longUrl').value;"
                "    const customCode = document.getElementById('customCode').value;"
                "    "
                "    const formData = new URLSearchParams();"
                "    formData.append('url', longUrl);"
                "    formData.append('custom', customCode);"
                "    "
                "    fetch('/api/shorten', {"
                "        method: 'POST',"
                "        headers: {'Content-Type': 'application/x-www-form-urlencoded'},"
                "        body: formData.toString()"
                "    })"
                "    .then(response => response.json())"
                "    .then(data => {"
                "        if (data.status === 'success') {"
                "            document.getElementById('shortUrl').href = data.short_url;"
                "            document.getElementById('shortUrl').textContent = data.short_url;"
                "            document.getElementById('result').style.display = 'block';"
                "            setTimeout(() => window.location.reload(), 2000);"
                "        } else {"
                "            alert('Error: ' + data.message);"
                "        }"
                "    });"
                "    "
                "    return false;"
                "}"
                ""
                "function copyToClipboard() {"
                "    const shortUrl = document.getElementById('shortUrl').textContent;"
                "    navigator.clipboard.writeText(shortUrl).then(() => {"
                "        alert('Copied to clipboard!');"
                "    });"
                "}"
                "</script>";
        
        return generate_generic_app(session_id, "URL Shortener", "ğŸ”—",
            "Create and manage shortened URLs", content);
    }
    
    std::string generate_system_monitor_app(const std::string& session_id) {
        system_monitor_.update();
        auto metrics = system_monitor_.get_metrics();
        
        std::stringstream ss;
        ss << std::fixed << std::setprecision(1);
        
        std::string content = R"HTML(
<style>
    .chart-container {
        background: white;
        padding: 1.5rem;
        border-radius: 8px;
        margin-bottom: 2rem;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .chart-title {
        font-size: 1.2rem;
        font-weight: bold;
        color: #2c3e50;
        margin-bottom: 1rem;
    }
    .chart-canvas {
        width: 100%;
        height: 200px;
    }
    .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1rem;
        margin-bottom: 2rem;
    }
    .stat-card {
        background: white;
        padding: 1.5rem;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .stat-label {
        color: #7f8c8d;
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
    }
    .stat-value {
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 0.5rem;
    }
    .stat-subtext {
        color: #95a5a6;
        font-size: 0.85rem;
    }
    .connection-status {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background: rgba(255, 255, 255, 0.15);
        border-radius: 20px;
        font-size: 0.9rem;
    }
    .status-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        animation: pulse 2s ease-in-out infinite;
    }
    .status-connected {
        background: #27ae60;
        box-shadow: 0 0 10px #27ae60;
    }
    .status-disconnected {
        background: #e74c3c;
        box-shadow: 0 0 10px #e74c3c;
    }
    .status-connecting {
        background: #f39c12;
        box-shadow: 0 0 10px #f39c12;
    }
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }
</style>

<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; border-radius: 8px; margin-bottom: 2rem;">
    <div style="display: flex; justify-content: space-between; align-items: flex-start; flex-wrap: wrap; gap: 1rem;">
        <div>
            <h2 style="margin: 0 0 0.5rem 0;">ğŸ“Š System Monitor</h2>
            <p style="margin: 0; opacity: 0.9;">Real-time performance metrics with live charts</p>
        </div>
        <div class="connection-status" id="connection-indicator">
            <span class="status-dot status-connecting"></span>
            <span id="connection-text">Connecting...</span>
        </div>
    </div>
    <div style="margin-top: 1rem; font-size: 0.9rem; opacity: 0.8;">
        Auto-refreshing every 2 seconds â€¢ <span id="update-status">Active</span>
    </div>
</div>

<div class="stats-grid">
    <div class="stat-card">
        <div class="stat-label">CPU Usage</div>
        <div class="stat-value" style="color: #3498db;"><span id="cpu-current">0</span>%</div>
        <div class="stat-subtext">Current load</div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Memory Usage</div>
        <div class="stat-value" style="color: #9b59b6;"><span id="mem-current">0</span>%</div>
        <div class="stat-subtext"><span id="mem-detail">0 / 0 GB</span></div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Disk Usage</div>
        <div class="stat-value" style="color: #e67e22;"><span id="disk-current">0</span>%</div>
        <div class="stat-subtext"><span id="disk-detail">0 / 0 GB</span></div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Network Activity</div>
        <div class="stat-value" style="color: #27ae60;">
            <span style="font-size: 1rem;">â†“</span> <span id="net-rx">0</span> 
            <span style="font-size: 1rem;">â†‘</span> <span id="net-tx">0</span>
        </div>
        <div class="stat-subtext">Mbps</div>
    </div>
</div>

<div class="chart-container">
    <div class="chart-title">CPU Usage Over Time</div>
    <canvas id="cpu-chart" class="chart-canvas"></canvas>
</div>

<div class="chart-container">
    <div class="chart-title">Memory Usage Over Time</div>
    <canvas id="memory-chart" class="chart-canvas"></canvas>
</div>

<div class="chart-container">
    <div class="chart-title">Network Activity</div>
    <canvas id="network-chart" class="chart-canvas"></canvas>
</div>

<div class="chart-container">
    <div class="chart-title">System Logs & Service Output</div>
    <div id="console-output" style="background: #1e1e1e; color: #d4d4d4; font-family: 'Courier New', monospace; font-size: 0.85rem; padding: 1rem; border-radius: 4px; height: 200px; overflow-y: auto; line-height: 1.5;">
        <div style="color: #4ec9b0;">System Monitor initialized...</div>
        <div style="color: #9cdcfe;">Waiting for data...</div>
    </div>
</div>

<div style="text-align: center; margin-top: 2rem;">
    <button id="pause-btn" onclick="toggleUpdates()" 
            style="background: #e74c3c; color: white; border: none; padding: 0.75rem 2rem; border-radius: 4px; cursor: pointer; font-size: 1rem; margin-right: 1rem;">
        &#9208;&#65039; Pause Updates
    </button>
    <button onclick="clearCharts()" 
            style="background: #95a5a6; color: white; border: none; padding: 0.75rem 2rem; border-radius: 4px; cursor: pointer; font-size: 1rem;">
        &#128465;&#65039; Clear History
    </button>
</div>

<script>
// Chart data storage
const maxDataPoints = 60; // Keep last 60 data points (2 minutes at 2-second intervals)
const chartData = {
    cpu: [],
    memory: [],
    networkRx: [],
    networkTx: [],
    labels: []
};

let updateInterval = null;
let isPaused = false;

// Initialize canvases
const cpuCanvas = document.getElementById('cpu-chart');
const memCanvas = document.getElementById('memory-chart');
const netCanvas = document.getElementById('network-chart');

const cpuCtx = cpuCanvas.getContext('2d');
const memCtx = memCanvas.getContext('2d');
const netCtx = netCanvas.getContext('2d');

// Set canvas sizes
function resizeCanvases() {
    [cpuCanvas, memCanvas, netCanvas].forEach(canvas => {
        canvas.width = canvas.offsetWidth * window.devicePixelRatio;
        canvas.height = canvas.offsetHeight * window.devicePixelRatio;
        const ctx = canvas.getContext('2d');
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    });
}
resizeCanvases();
window.addEventListener('resize', resizeCanvases);

// Draw line chart
function drawChart(ctx, canvas, data, color, label, max = 100) {
    const width = canvas.offsetWidth;
    const height = canvas.offsetHeight;
    const padding = 40;
    const chartWidth = width - padding * 2;
    const chartHeight = height - padding * 2;
    
    ctx.clearRect(0, 0, width, height);
    
    // Draw grid
    ctx.strokeStyle = '#ecf0f1';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
        const y = padding + (chartHeight / 5) * i;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
        
        // Y-axis labels
        ctx.fillStyle = '#7f8c8d';
        ctx.font = '12px Arial';
        ctx.textAlign = 'right';
        ctx.fillText((max - (max / 5) * i).toFixed(0), padding - 10, y + 4);
    }
    
    if (data.length < 2) return;
    
    // Draw line
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    data.forEach((value, index) => {
        const x = padding + (chartWidth / (maxDataPoints - 1)) * index;
        const y = padding + chartHeight - (value / max) * chartHeight;
        
        if (index === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    });
    
    ctx.stroke();
    
    // Draw filled area
    ctx.lineTo(padding + (chartWidth / (maxDataPoints - 1)) * (data.length - 1), padding + chartHeight);
    ctx.lineTo(padding, padding + chartHeight);
    ctx.closePath();
    
    const gradient = ctx.createLinearGradient(0, padding, 0, height - padding);
    gradient.addColorStop(0, color + '40');
    gradient.addColorStop(1, color + '00');
    ctx.fillStyle = gradient;
    ctx.fill();
    
    // Draw points
    ctx.fillStyle = color;
    data.forEach((value, index) => {
        const x = padding + (chartWidth / (maxDataPoints - 1)) * index;
        const y = padding + chartHeight - (value / max) * chartHeight;
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
    });
    
    // Draw current value
    if (data.length > 0) {
        const lastValue = data[data.length - 1];
        ctx.fillStyle = color;
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(label + ': ' + lastValue.toFixed(1), padding, 20);
    }
}

// Fetch and update metrics
function updateMetrics() {
    fetch('http://localhost:9001/api/metrics')
        .then(res => {
            if (!res.ok) throw new Error('HTTP ' + res.status);
            return res.json();
        })
        .then(data => {
            // Update connection status to connected
            updateConnectionStatus('connected');
            
            // Log to console
            const timestamp = new Date().toLocaleTimeString();
            logToConsole('info', timestamp + ' - Metrics updated: CPU ' + data.cpu.toFixed(1) + '%, Memory ' + data.memory.toFixed(1) + '%');
            
            // Update stat cards
            document.getElementById('cpu-current').textContent = data.cpu.toFixed(1);
            document.getElementById('mem-current').textContent = data.memory.toFixed(1);
            document.getElementById('disk-current').textContent = data.disk.toFixed(1);
            document.getElementById('net-rx').textContent = data.network_rx.toFixed(1);
            document.getElementById('net-tx').textContent = data.network_tx.toFixed(1);
            
            document.getElementById('mem-detail').textContent = 
                (data.memory * 16 / 100 / 1024).toFixed(1) + ' / 16 GB (est)';
            document.getElementById('disk-detail').textContent = 
                (data.disk * 500 / 100).toFixed(1) + ' / 500 GB (est)';
            
            // Add to chart data
            chartData.cpu.push(data.cpu);
            chartData.memory.push(data.memory);
            chartData.networkRx.push(data.network_rx);
            chartData.networkTx.push(data.network_tx);
            
            const time = new Date().toLocaleTimeString();
            chartData.labels.push(time);
            
            // Keep only last maxDataPoints
            if (chartData.cpu.length > maxDataPoints) {
                chartData.cpu.shift();
                chartData.memory.shift();
                chartData.networkRx.shift();
                chartData.networkTx.shift();
                chartData.labels.shift();
            }
            
            // Redraw charts
            drawChart(cpuCtx, cpuCanvas, chartData.cpu, '#3498db', 'CPU', 100);
            drawChart(memCtx, memCanvas, chartData.memory, '#9b59b6', 'Memory', 100);
            
            // Network chart with two lines
            const netMax = Math.max(
                Math.max(...chartData.networkRx, 10),
                Math.max(...chartData.networkTx, 10)
            );
            drawChart(netCtx, netCanvas, chartData.networkRx, '#27ae60', 'â†“ Download', netMax);
            
            // Draw upload line on same chart
            const ctx = netCtx;
            const canvas = netCanvas;
            const data = chartData.networkTx;
            const color = '#e74c3c';
            const width = canvas.offsetWidth;
            const height = canvas.offsetHeight;
            const padding = 40;
            const chartWidth = width - padding * 2;
            const chartHeight = height - padding * 2;
            
            if (data.length >= 2) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                data.forEach((value, index) => {
                    const x = padding + (chartWidth / (maxDataPoints - 1)) * index;
                    const y = padding + chartHeight - (value / netMax) * chartHeight;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = color;
                data.forEach((value, index) => {
                    const x = padding + (chartWidth / (maxDataPoints - 1)) * index;
                    const y = padding + chartHeight - (value / netMax) * chartHeight;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw current value
                const lastValue = data[data.length - 1];
                ctx.fillStyle = color;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('â†‘ Upload: ' + lastValue.toFixed(1), padding + 150, 20);
            }
        })
        .catch(err => {
            console.error('Failed to fetch metrics:', err);
            updateConnectionStatus('disconnected');
            logToConsole('error', 'Connection failed: ' + err.message);
            document.getElementById('update-status').textContent = 'Error';
        });
}

function logToConsole(level, message) {
    const consoleOutput = document.getElementById('console-output');
    if (!consoleOutput) return;
    
    const colors = {
        'info': '#9cdcfe',
        'success': '#4ec9b0',
        'warning': '#dcdcaa',
        'error': '#f48771'
    };
    
    const entry = document.createElement('div');
    entry.style.color = colors[level] || colors['info'];
    entry.textContent = message;
    
    consoleOutput.appendChild(entry);
    
    // Keep only last 50 lines
    while (consoleOutput.children.length > 50) {
        consoleOutput.removeChild(consoleOutput.firstChild);
    }
    
    // Auto-scroll to bottom
    consoleOutput.scrollTop = consoleOutput.scrollHeight;
}

function updateConnectionStatus(status) {
    const indicator = document.querySelector('#connection-indicator .status-dot');
    const text = document.getElementById('connection-text');
    
    indicator.className = 'status-dot';
    
    if (status === 'connected') {
        indicator.classList.add('status-connected');
        text.textContent = 'Connected';
    } else if (status === 'disconnected') {
        indicator.classList.add('status-disconnected');
        text.textContent = 'Disconnected';
    } else if (status === 'connecting') {
        indicator.classList.add('status-connecting');
        text.textContent = 'Connecting...';
    }
}

function toggleUpdates() {
    isPaused = !isPaused;
    const btn = document.getElementById('pause-btn');
    
    if (isPaused) {
        clearInterval(updateInterval);
        btn.innerHTML = 'â–¶ï¸ Resume Updates';
        btn.style.background = '#27ae60';
        document.getElementById('update-status').textContent = 'Paused';
    } else {
        updateInterval = setInterval(updateMetrics, 2000);
        btn.innerHTML = 'â¸ï¸ Pause Updates';
        btn.style.background = '#e74c3c';
        document.getElementById('update-status').textContent = 'Active';
    }
}

function clearCharts() {
    chartData.cpu = [];
    chartData.memory = [];
    chartData.networkRx = [];
    chartData.networkTx = [];
    chartData.labels = [];
    
    cpuCtx.clearRect(0, 0, cpuCanvas.width, cpuCanvas.height);
    memCtx.clearRect(0, 0, memCanvas.width, memCanvas.height);
    netCtx.clearRect(0, 0, netCanvas.width, netCanvas.height);
}

// Start updating
logToConsole('success', 'System Monitor started');
logToConsole('info', 'Connecting to backend service...');
updateConnectionStatus('connecting');
updateMetrics();
updateInterval = setInterval(updateMetrics, 2000);
</script>
)HTML";
        
        return generate_generic_app(session_id, "System Monitor", "ğŸ“Š",
            "Real-time system performance metrics", content);
    }
    
    std::string generate_service_breaker_app(const std::string& session_id) {
        auto services = service_breaker_.get_all_services();
        
        std::string content = R"(
<style>
    .service-card {
        background: white;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        border-left: 4px solid #3498db;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .service-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
    }
    .service-name {
        font-size: 1.3rem;
        font-weight: bold;
        color: #2c3e50;
    }
    .status-badge {
        padding: 0.5rem 1rem;
        border-radius: 4px;
        font-weight: bold;
        font-size: 0.9rem;
    }
    .status-running {
        background: #27ae60;
        color: white;
    }
    .status-stopped {
        background: #e74c3c;
        color: white;
    }
    .service-controls {
        display: flex;
        gap: 1rem;
        margin-top: 1rem;
        flex-wrap: wrap;
    }
    .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.95rem;
        font-weight: 500;
        transition: all 0.3s;
    }
    .btn-start {
        background: #27ae60;
        color: white;
    }
    .btn-start:hover {
        background: #229954;
    }
    .btn-stop {
        background: #e74c3c;
        color: white;
    }
    .btn-stop:hover {
        background: #c0392b;
    }
    .port-input {
        padding: 0.75rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 150px;
        font-size: 0.95rem;
    }
    .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }
    .spinner {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid rgba(255,255,255,0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 0.8s linear infinite;
        margin-right: 0.5rem;
        vertical-align: middle;
    }
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    .status-message {
        position: fixed;
        top: 2rem;
        right: 2rem;
        background: white;
        padding: 1rem 1.5rem;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 9999;
        animation: slideIn 0.3s ease-out;
    }
    @keyframes slideIn {
        from { transform: translateX(400px); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
</style>

<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 2rem; border-radius: 8px; margin-bottom: 2rem; color: white;">
    <h2 style="margin: 0; font-size: 2rem;">ğŸ”§ Service Breaker</h2>
    <p style="margin: 0.5rem 0 0 0; opacity: 0.9;">Control and configure all platform services</p>
</div>

<div id="services-container">
)";
        
        // Generate cards for each service
        for (const auto& [name, config] : services) {
            content += "<div class='service-card'>";
            content += "<div class='service-header'>";
            content += "<div><div class='service-name'>" + config.name + "</div>";
            content += "<div style='color: #7f8c8d; margin-top: 0.25rem;'>" + config.description + "</div></div>";
            content += "<div class='status-badge status-" + std::string(config.is_running ? "running" : "stopped") + "'>";
            content += config.is_running ? "ğŸŸ¢ Running" : "ğŸ”´ Stopped";
            content += "</div></div>";
            
            content += "<div style='display: flex; gap: 2rem; align-items: center; margin-top: 1rem; flex-wrap: wrap;'>";
            content += "<div><strong>Port:</strong> <input type='number' id='port-" + name + "' value='" + std::to_string(config.port) + "' class='port-input' min='1' max='65535'></div>";
            content += "<div><strong>Status:</strong> <span style='color: #7f8c8d;'>" + config.status_message + "</span></div>";
            content += "</div>";
            
            content += "<div class='service-controls'>";
            content += "<button class='btn btn-start' onclick='startService(\"" + name + "\")'>â–¶ï¸ Start</button>";
            content += "<button class='btn btn-stop' onclick='stopService(\"" + name + "\")'>â¹ï¸ Stop</button>";
            content += "<button class='btn' style='background: #3498db; color: white;' onclick='setPort(\"" + name + "\")'>ğŸ’¾ Set Port</button>";
            content += "</div></div>";
        }
        
        content += R"(
</div>

<script>
function showToast(message, type) {
    const toast = document.createElement('div');
    toast.className = 'status-message';
    toast.style.borderLeft = '4px solid ' + (type === 'success' ? '#27ae60' : '#e74c3c');
    toast.innerHTML = '<strong>' + (type === 'success' ? 'âœ“' : 'âœ—') + '</strong> ' + message;
    document.body.appendChild(toast);
    setTimeout(() => {
        toast.style.animation = 'slideIn 0.3s ease-out reverse';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

function setButtonLoading(button, loading) {
    if (loading) {
        button.disabled = true;
        button.setAttribute('data-original-text', button.innerHTML);
        button.innerHTML = '<span class="spinner"></span>' + button.getAttribute('data-action') + 'ing...';
    } else {
        button.disabled = false;
        button.innerHTML = button.getAttribute('data-original-text');
    }
}

function startService(serviceName) {
    const button = event.target;
    button.setAttribute('data-action', 'Start');
    setButtonLoading(button, true);
    
    fetch('/api/service/start', {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: 'service=' + serviceName
    })
    .then(res => res.json())
    .then(data => {
        if (data.status === 'success') {
            showToast('Service ' + serviceName + ' started successfully', 'success');
            setTimeout(() => window.location.reload(), 1000);
        } else {
            showToast('Failed to start service ' + serviceName, 'error');
            setButtonLoading(button, false);
        }
    })
    .catch(err => {
        showToast('Error starting service: ' + err.message, 'error');
        setButtonLoading(button, false);
    });
}

function stopService(serviceName) {
    const button = event.target;
    button.setAttribute('data-action', 'Stop');
    setButtonLoading(button, true);
    
    fetch('/api/service/stop', {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: 'service=' + serviceName
    })
    .then(res => res.json())
    .then(data => {
        if (data.status === 'success') {
            showToast('Service ' + serviceName + ' stopped successfully', 'success');
            setTimeout(() => window.location.reload(), 1000);
        } else {
            showToast('Failed to stop service ' + serviceName, 'error');
            setButtonLoading(button, false);
        }
    })
    .catch(err => {
        showToast('Error stopping service: ' + err.message, 'error');
        setButtonLoading(button, false);
    });
}

function setPort(serviceName) {
    const button = event.target;
    const port = document.getElementById('port-' + serviceName).value;
    
    if (port < 1 || port > 65535) {
        showToast('Invalid port number. Must be between 1 and 65535.', 'error');
        return;
    }
    
    button.setAttribute('data-action', 'Sav');
    setButtonLoading(button, true);
    
    fetch('/api/service/setport', {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: 'service=' + serviceName + '&port=' + port
    })
    .then(res => res.json())
    .then(data => {
        if (data.status === 'success') {
            showToast('Port for ' + serviceName + ' set to ' + port, 'success');
            setTimeout(() => window.location.reload(), 1000);
        } else {
            showToast('Failed to set port for ' + serviceName, 'error');
            setButtonLoading(button, false);
        }
    })
    .catch(err => {
        showToast('Error setting port: ' + err.message, 'error');
        setButtonLoading(button, false);
    });
}
</script>
)";
        
        return generate_generic_app(session_id, "Service Breaker", "ğŸ”§",
            "Control and configure all platform services", content);
    }
    
    std::string generate_admin_panel(const std::string& session_id) {
        
        auto users = auth_system_->list_users();
        std::stringstream users_html;
        for (const auto& username : users) {
            auto* user = auth_system_->get_user(username);
            if (user) {
                users_html << "<tr><td>" << username << "</td>"
                          << "<td>" << user->email << "</td>"
                          << "<td>" << role_to_string(user->role) << "</td>"
                          << "<td style='color: " << (user->is_active ? "green" : "red") << ";'>" 
                          << (user->is_active ? "âœ“ Active" : "âœ— Inactive") << "</td></tr>";
            }
        }
        
        std::string content = 
            "<h3>Server Control</h3>"
            "<div style=\"background: white; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;\">"
            "    <p style=\"margin-bottom: 1rem;\"><strong>Account Server Status:</strong> "
            "    <span id=\"server-status\" style=\"color: orange;\">âš  Not Running</span></p>"
            "    <button onclick=\"startAccountServer()\" "
            "        style=\"background: #27ae60; color: white; border: none; "
            "               padding: 0.75rem 1.5rem; border-radius: 4px; cursor: pointer; font-size: 1rem;\">"
            "        ğŸš€ Start Account Server"
            "    </button>"
            "</div>"
            
            "<h3>Create New User</h3>"
            "<form id=\"createUserForm\" onsubmit=\"return createUser(event);\" "
            "      style=\"background: white; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem;\">"
            "    <div style=\"margin-bottom: 1rem;\">"
            "        <label style=\"display: block; margin-bottom: 0.5rem; font-weight: bold;\">Username</label>"
            "        <input type=\"text\" id=\"username\" required placeholder=\"newuser\" "
            "               style=\"width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem;\">"
            "    </div>"
            "    <div style=\"margin-bottom: 1rem;\">"
            "        <label style=\"display: block; margin-bottom: 0.5rem; font-weight: bold;\">Email</label>"
            "        <input type=\"email\" id=\"email\" required placeholder=\"user@example.com\" "
            "               style=\"width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem;\">"
            "    </div>"
            "    <div style=\"margin-bottom: 1rem;\">"
            "        <label style=\"display: block; margin-bottom: 0.5rem; font-weight: bold;\">Password</label>"
            "        <input type=\"password\" id=\"password\" required placeholder=\"password123\" "
            "               style=\"width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem;\">"
            "    </div>"
            "    <div style=\"margin-bottom: 1rem;\">"
            "        <label style=\"display: block; margin-bottom: 0.5rem; font-weight: bold;\">Role</label>"
            "        <select id=\"role\" style=\"width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 4px; font-size: 1rem;\">"
            "            <option value=\"user\">User</option>"
            "            <option value=\"admin\">Admin</option>"
            "        </select>"
            "    </div>"
            "    <button type=\"submit\" style=\"background: #3498db; color: white; border: none; "
            "                                    padding: 0.75rem 2rem; border-radius: 4px; cursor: pointer; font-size: 1rem;\">"
            "        â• Create User"
            "    </button>"
            "</form>"
            
            "<h3>Existing Users</h3>"
            "<div style=\"background: white; padding: 1.5rem; border-radius: 8px; margin-bottom: 2rem; overflow-x: auto;\">"
            "    <table style=\"width: 100%; border-collapse: collapse;\">"
            "        <thead>"
            "            <tr style=\"background: #f8f9fa; border-bottom: 2px solid #dee2e6;\">"
            "                <th style=\"padding: 1rem; text-align: left; font-weight: bold;\">Username</th>"
            "                <th style=\"padding: 1rem; text-align: left; font-weight: bold;\">Email</th>"
            "                <th style=\"padding: 1rem; text-align: left; font-weight: bold;\">Role</th>"
            "                <th style=\"padding: 1rem; text-align: left; font-weight: bold;\">Status</th>"
            "            </tr>"
            "        </thead>"
            "        <tbody id=\"users-table\">"
            + users_html.str() +
            "        </tbody>"
            "    </table>"
            "</div>"
            
            "<h3>System Statistics</h3>"
            "<div style=\"background: white; padding: 1.5rem; border-radius: 8px;\">"
            "    <p style=\"margin-bottom: 0.5rem;\"><strong>Active Sessions:</strong> " + 
                    std::to_string(auth_system_->get_active_sessions_count()) + "</p>"
            "    <p style=\"margin-bottom: 0.5rem;\"><strong>Total Users:</strong> " + 
                    std::to_string(auth_system_->get_total_users()) + "</p>"
            "    <p style=\"margin-bottom: 0.5rem;\"><strong>Platform:</strong> ToolBox MATLAB-Style</p>"
            "    <p style=\"margin-bottom: 0.5rem;\"><strong>Port:</strong> 9000</p>"
            "</div>"
            
            "<script>"
            "function startAccountServer() {"
            "    fetch('/api/start_account_server')"
            "        .then(response => response.json())"
            "        .then(data => {"
            "            document.getElementById('server-status').innerHTML = 'âœ“ Running on port 8888';"
            "            document.getElementById('server-status').style.color = 'green';"
            "            alert(data.message);"
            "        })"
            "        .catch(err => alert('Error starting server'));"
            "}"
            ""
            "function createUser(event) {"
            "    event.preventDefault();"
            "    const formData = new URLSearchParams();"
            "    formData.append('username', document.getElementById('username').value);"
            "    formData.append('email', document.getElementById('email').value);"
            "    formData.append('password', document.getElementById('password').value);"
            "    formData.append('role', document.getElementById('role').value);"
            "    "
            "    fetch('/api/create_user', {"
            "        method: 'POST',"
            "        headers: {'Content-Type': 'application/x-www-form-urlencoded'},"
            "        body: formData.toString()"
            "    })"
            "    .then(() => window.location.reload())"
            "    .catch(err => alert('Error creating user'));"
            "    "
            "    return false;"
            "}"
            "</script>";
        
        return generate_generic_app(session_id, "Admin Panel", "âš™ï¸",
            "System and user administration", content);
    }
    
    std::string generate_account_management(const std::string& session_id) {
        // Get current user info (using default guest for passwordless mode)
        std::string username = "Guest";
        std::string email = "guest@toolbox.local";
        std::string role = "User";
        std::string status = "Active";
        
        // Get system preferences
        std::time_t now = std::time(nullptr);
        std::tm* local_time = std::localtime(&now);
        char time_buffer[64];
        std::strftime(time_buffer, sizeof(time_buffer), "%Y-%m-%d %H:%M:%S", local_time);
        
        return generate_generic_app(session_id, "Account Management", "ğŸ‘¤",
            "Manage your profile and preferences",
            R"(
                <h3>Profile Information</h3>
                <form-input label="Username" value=")" + username + R"(" placeholder="username"></form-input>
                <form-input label="Email" value=")" + email + R"(" placeholder="user@example.com"></form-input>
                <form-input label="Display Name" placeholder="Full Name"></form-input>
                <app-button>Update Profile</app-button>
                
                <h3 style="margin-top: 2rem;">Account Status</h3>
                <div style="background: white; padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;">
                    <p><strong>Role:</strong> )" + role + R"(</p>
                    <p><strong>Status:</strong> )" + status + R"(</p>
                    <p><strong>Last Login:</strong> )" + std::string(time_buffer) + R"(</p>
                    <p><strong>Sessions:</strong> )" + std::to_string(auth_system_->get_active_sessions_count()) + R"( active</p>
                </div>
                
                <h3 style="margin-top: 2rem;">Security Settings</h3>
                <form-input label="Current Password" type="password" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"></form-input>
                <form-input label="New Password" type="password" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"></form-input>
                <form-input label="Confirm Password" type="password" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"></form-input>
                <app-button>Change Password</app-button>
                
                <h3 style="margin-top: 2rem;">Preferences</h3>
                <div style="background: white; padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;">
                    <label style="display: block; margin-bottom: 1rem;">
                        <input type="checkbox" checked> Enable email notifications
                    </label>
                    <label style="display: block; margin-bottom: 1rem;">
                        <input type="checkbox"> Dark mode
                    </label>
                    <label style="display: block; margin-bottom: 1rem;">
                        <input type="checkbox" checked> Show system statistics
                    </label>
                </div>
                <app-button>Save Preferences</app-button>
                
                <h3 style="margin-top: 2rem;">Account Actions</h3>
                <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                    <app-button>Export Data</app-button>
                    <app-button>Clear Sessions</app-button>
                    <app-button style="background: #e74c3c;">Delete Account</app-button>
                </div>
            )");
    }
    
    std::string list_frontends_json() {
        std::string json = "{\"frontends\":[";        
        std::vector<std::string> frontends;
        
        // Scan frontends directory
        system("ls -d ./frontends/*/ 2>/dev/null > /tmp/frontend_list.txt");
        std::ifstream list_file("/tmp/frontend_list.txt");
        std::string line;
        bool first = true;
        
        while (std::getline(list_file, line)) {
            if (line.empty()) continue;
            
            // Extract frontend name from path
            size_t last_slash = line.find_last_of('/', line.length() - 2);
            std::string name = line.substr(last_slash + 1);
            name.pop_back(); // Remove trailing slash
            
            // Read package.json if exists
            std::string pkg_path = "./frontends/" + name + "/package.json";
            std::ifstream pkg_file(pkg_path);
            std::string description = "Bun.js frontend";
            int port = 3000;
            
            if (pkg_file.good()) {
                std::string pkg_content((std::istreambuf_iterator<char>(pkg_file)),
                                       std::istreambuf_iterator<char>());
                // Simple parsing for description and port
                size_t desc_pos = pkg_content.find("\"description\":");
                if (desc_pos != std::string::npos) {
                    size_t start = pkg_content.find("\"", desc_pos + 15) + 1;
                    size_t end = pkg_content.find("\"", start);
                    if (start != std::string::npos && end != std::string::npos) {
                        description = pkg_content.substr(start, end - start);
                    }
                }
            }
            
            if (!first) json += ",";
            first = false;
            
            json += "{\"name\":\"" + name + "\",";
            json += "\"description\":\"" + description + "\",";
            json += "\"port\":" + std::to_string(port) + ",";
            json += "\"status\":\"stopped\"}";
        }
        
        json += "]}";
        return "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json;
    }
    
    std::string create_frontend_boilerplate(const std::string& post_data) {
        // Parse form data
        std::map<std::string, std::string> params;
        std::istringstream ss(post_data);
        std::string pair;
        while (std::getline(ss, pair, '&')) {
            size_t eq = pair.find('=');
            if (eq != std::string::npos) {
                std::string key = pair.substr(0, eq);
                std::string value = url_decode(pair.substr(eq + 1));
                params[key] = value;
            }
        }
        
        std::string name = params["name"];
        std::string description = params["description"];
        std::string port = params["port"];
        std::string backend_port = params["backend_port"];
        
        if (name.empty() || port.empty()) {
            return "HTTP/1.1 400 Bad Request\r\nContent-Type: application/json\r\n\r\n{\"error\":\"Name and port required\"}";
        }
        
        // Create directory
        std::string frontend_dir = "./frontends/" + name;
        std::string cmd = "mkdir -p " + frontend_dir + "/public";
        system(cmd.c_str());
        
        // Create server.ts
        std::ofstream server_file(frontend_dir + "/server.ts");
        server_file << "Bun.serve({\n";
        server_file << "  port: " << port << ",\n";
        server_file << "  async fetch(req) {\n";
        server_file << "    const url = new URL(req.url);\n";
        server_file << "    \n";
        server_file << "    // API proxy\n";
        server_file << "    if (url.pathname.startsWith('/api/')) {\n";
        server_file << "      const backendUrl = `http://localhost:" << backend_port << "${url.pathname}${url.search}`;\n";
        server_file << "      return fetch(backendUrl, {\n";
        server_file << "        method: req.method,\n";
        server_file << "        headers: req.headers,\n";
        server_file << "        body: req.method !== 'GET' && req.method !== 'HEAD' ? await req.text() : undefined\n";
        server_file << "      });\n";
        server_file << "    }\n";
        server_file << "    \n";
        server_file << "    // Serve static files\n";
        server_file << "    const filePath = url.pathname === '/' ? '/index.html' : url.pathname;\n";
        server_file << "    const file = Bun.file(`./public${filePath}`);\n";
        server_file << "    if (await file.exists()) {\n";
        server_file << "      return new Response(file);\n";
        server_file << "    }\n";
        server_file << "    \n";
        server_file << "    return new Response('Not Found', { status: 404 });\n";
        server_file << "  }\n";
        server_file << "});\n\n";
        server_file << "console.log(`ğŸš€ " << name << " running on http://localhost:" << port << "`);\n";
        server_file.close();
        
        // Create package.json
        std::ofstream pkg_file(frontend_dir + "/package.json");
        pkg_file << "{\n";
        pkg_file << "  \"name\": \"" << name << "\",\n";
        pkg_file << "  \"version\": \"1.0.0\",\n";
        pkg_file << "  \"description\": \"" << description << "\",\n";
        pkg_file << "  \"type\": \"module\",\n";
        pkg_file << "  \"scripts\": {\n";
        pkg_file << "    \"dev\": \"bun run server.ts\",\n";
        pkg_file << "    \"start\": \"bun run server.ts\"\n";
        pkg_file << "  }\n";
        pkg_file << "}\n";
        pkg_file.close();
        
        // Create index.html
        std::ofstream html_file(frontend_dir + "/public/index.html");
        html_file << "<!DOCTYPE html>\n<html>\n<head>\n";
        html_file << "    <meta charset=\"utf-8\">\n";
        html_file << "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n";
        html_file << "    <title>" << name << "</title>\n";
        html_file << "    <link rel=\"stylesheet\" href=\"/styles.css\">\n";
        html_file << "</head>\n<body>\n";
        html_file << "    <div class=\"container\">\n";
        html_file << "        <header>\n";
        html_file << "            <h1>" << name << "</h1>\n";
        html_file << "            <p>" << description << "</p>\n";
        html_file << "        </header>\n";
        html_file << "        <main id=\"app\">\n";
        html_file << "            <p>Welcome to your new frontend!</p>\n";
        html_file << "        </main>\n";
        html_file << "    </div>\n";
        html_file << "    <script src=\"/app.js\"></script>\n";
        html_file << "</body>\n</html>\n";
        html_file.close();
        
        // Create styles.css
        std::ofstream css_file(frontend_dir + "/public/styles.css");
        css_file << "* { margin: 0; padding: 0; box-sizing: border-box; }\n";
        css_file << "body { font-family: system-ui, -apple-system, sans-serif; background: #0a0a0a; color: #e0e0e0; line-height: 1.6; }\n";
        css_file << ".container { max-width: 1200px; margin: 0 auto; padding: 2rem; }\n";
        css_file << "header { text-align: center; padding: 3rem 0; }\n";
        css_file << "h1 { font-size: 2.5rem; background: linear-gradient(135deg, #8b5cf6 0%, #3b82f6 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }\n";
        css_file << "main { background: #1a1a1a; padding: 2rem; border-radius: 8px; margin-top: 2rem; }\n";
        css_file.close();
        
        // Create app.js
        std::ofstream js_file(frontend_dir + "/public/app.js");
        js_file << "// " << name << " - Frontend Application\n\n";
        js_file << "console.log('" << name << " loaded');\n\n";
        js_file << "// Add your application logic here\n";
        js_file.close();
        
        // Create README
        std::ofstream readme_file(frontend_dir + "/README.md");
        readme_file << "# " << name << "\n\n";
        readme_file << description << "\n\n";
        readme_file << "## Quick Start\n\n";
        readme_file << "```bash\n";
        readme_file << "bun install\n";
        readme_file << "bun dev\n";
        readme_file << "```\n\n";
        readme_file << "Frontend will be available at http://localhost:" << port << "\n";
        readme_file.close();
        
        return "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"success\":true,\"message\":\"Frontend created successfully\",\"path\":\"frontends/" + name + "\"}";
    }
    
    std::string generate_generic_app(const std::string& session_id, const std::string& app_name,
                                    const std::string& icon, const std::string& description,
                                    const std::string& content) {
        
        ComponentBundler bundler;
        
        return bundler
            .set_title(app_name + " - MATLAB Style")
            .add_component_from_registry("app-button")
            .add_component_from_registry("form-input")
            .add_component_from_registry("progress-bar")
            .add_component_from_registry("data-table")
            .add_global_style(R"(
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body { font-family: Arial, Helvetica, sans-serif; background: #f0f0f0; }
                .app-header {
                    background: #2c3e50;
                    color: white;
                    padding: 1rem 2rem;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
                .app-header h1 { font-size: 1.5rem; color: white; }
                .back-btn {
                    background: #34495e;
                    color: white;
                    padding: 0.5rem 1rem;
                    border-radius: 4px;
                    text-decoration: none;
                }
                .app-container {
                    max-width: 1200px;
                    margin: 2rem auto;
                    background: white;
                    border-radius: 8px;
                    padding: 2rem;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                }
                .app-icon { font-size: 3rem; margin-bottom: 1rem; }
                h2 { color: #2c3e50; margin-bottom: 0.5rem; }
                h3 { color: #34495e; margin: 1.5rem 0 1rem; }
                p { color: #7f8c8d; margin: 0.5rem 0; }
                .version-footer {
                    position: fixed;
                    bottom: 1rem;
                    right: 1rem;
                    background: rgba(255, 255, 255, 0.9);
                    padding: 0.5rem 1rem;
                    border-radius: 4px;
                    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
                    font-size: 0.8rem;
                    color: #7f8c8d;
                    z-index: 1000;
                }
                .version-footer strong {
                    color: #2c3e50;
                }
            )")
            .set_body_content(R"(
                <div class="app-header">
                    <h1>)" + icon + " " + app_name + R"(</h1>
                    <a href="/" class="back-btn">â† Back to Apps</a>
                </div>
                <div class="app-container">
                    <div class="app-icon">)" + icon + R"(</div>
                    <h2>)" + app_name + R"(</h2>
                    <p>)" + description + R"(</p>
                    <hr style="margin: 2rem 0; border: 1px solid #ecf0f1;">
                    )" + content + R"(
                </div>
                
                <div class="version-footer">
                    <strong>ToolBox Platform</strong> v1.0.0
                </div>
            )")
            .minify(true)
            .bundle();
    }
};

void print_service_tui(ServiceManager& manager, RequestLogger* logger = nullptr) {
    auto term_size = get_terminal_size();
    
    // Clear screen and hide cursor
    std::cout << "\033[2J\033[H\033[?25l";
    
    std::cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘           ğŸš€ MATLAB-Style Platform - Service Manager ğŸš€              â•‘\n";
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    
    auto services = manager.get_services();
    
    // Backend Services Section
    std::cout << "\033[1mâš™ï¸  BACKEND SERVICES\033[0m\n";
    std::cout << "â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
    std::cout << "â”‚ ID â”‚ SERVICE NAME            â”‚ PORT â”‚ STATUS   â”‚ DESCRIPTION           â”‚\n";
    std::cout << "â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n";
    
    for (const auto& [id, svc] : services) {
        if (id <= 3) {  // Backend services: 1-3
            std::string status = svc.running ? "\033[32mâ— RUN \033[0m" : "\033[31mâ—‹ STOP\033[0m";
            printf("â”‚ %2d â”‚ %-23s â”‚ %4d â”‚ %s â”‚ %-21s â”‚\n", 
                   id, svc.name.c_str(), svc.port, status.c_str(), svc.description.c_str());
        }
    }
    
    std::cout << "â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
    
    // Frontend Services Section
    std::cout << "\033[1mğŸ¨ FRONTEND SERVICES\033[0m\n";
    std::cout << "â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
    std::cout << "â”‚ ID â”‚ SERVICE NAME            â”‚ PORT â”‚ STATUS   â”‚ DESCRIPTION           â”‚\n";
    std::cout << "â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n";
    
    for (const auto& [id, svc] : services) {
        if (id >= 4) {  // Frontend services: 4-6
            std::string status = svc.running ? "\033[32mâ— RUN \033[0m" : "\033[31mâ—‹ STOP\033[0m";
            std::string desc = svc.description;
            if (svc.command.empty() && !svc.running) {
                desc = "\033[90m" + desc + "\033[0m";  // Dim if not implemented
            }
            printf("â”‚ %2d â”‚ %-23s â”‚ %4d â”‚ %s â”‚ %-21s â”‚\n", 
                   id, svc.name.c_str(), svc.port, status.c_str(), desc.c_str());
        }
    }
    
    std::cout << "â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
    
    // Request Log Section
    if (logger) {
        std::cout << "\033[1mğŸ“Š RECENT HTTP REQUESTS (Last 15)\033[0m\n";
        std::cout << "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n";
        std::cout << "â”‚ TIMESTAMP   â”‚ METHOD â”‚ PATH                                             â”‚\n";
        std::cout << "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n";
        
        auto logs = logger->get_recent_logs(15);
        if (logs.empty()) {
            std::cout << "â”‚ \033[90mNo requests yet...                                                 \033[0mâ”‚\n";
        } else {
            for (const auto& log : logs) {
                std::string path = log.path;
                if (path.length() > 45) {
                    path = path.substr(0, 42) + "...";
                }
                
                // Color code by method
                std::string method_color;
                if (log.method == "GET") method_color = "\033[32m";  // Green
                else if (log.method == "POST") method_color = "\033[33m";  // Yellow
                else method_color = "\033[36m";  // Cyan
                
                printf("â”‚ %-11s â”‚ %s%-6s\033[0m â”‚ %-45s â”‚\n",
                       log.timestamp.c_str(),
                       method_color.c_str(),
                       log.method.c_str(),
                       path.c_str());
            }
        }
        
        std::cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n";
    }
    
    std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘                              COMMANDS                                 â•‘\n";
    std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
    std::cout << "â•‘  \033[1mBackend Services:\033[0m                                                     â•‘\n";
    std::cout << "â•‘  \033[1m[1-3]\033[0m      - Start backend by ID                                    â•‘\n";
    std::cout << "â•‘  \033[1ms [1-3]\033[0m   - Stop backend by ID                                     â•‘\n";
    std::cout << "â•‘  \033[1mr [1-3]\033[0m   - Restart backend by ID                                  â•‘\n";
    std::cout << "â•‘  \033[1mlog [1-3]\033[0m - View backend logs                                       â•‘\n";
    std::cout << "â•‘                                                                       â•‘\n";
    std::cout << "â•‘  \033[1mFrontend Services:\033[0m                                                    â•‘\n";
    std::cout << "â•‘  \033[1mf [4-6]\033[0m   - Start frontend by ID (e.g., 'f 4')                     â•‘\n";
    std::cout << "â•‘  \033[1msf [4-6]\033[0m  - Stop frontend by ID (e.g., 'sf 4')                     â•‘\n";
    std::cout << "â•‘  \033[1mrf [4-6]\033[0m  - Restart frontend by ID (e.g., 'rf 4')                  â•‘\n";
    std::cout << "â•‘  \033[1mlog [4-6]\033[0m - View frontend logs                                      â•‘\n";
    std::cout << "â•‘                                                                       â•‘\n";
    std::cout << "â•‘  \033[1mGeneral:\033[0m                                                              â•‘\n";
    std::cout << "â•‘  \033[1mrefresh\033[0m   - Refresh status display                                  â•‘\n";
    std::cout << "â•‘  \033[1mopen\033[0m      - Open main UI in browser (http://localhost:9000)        â•‘\n";
    std::cout << "â•‘  \033[1mquit\033[0m      - Stop all services and exit                              â•‘\n";
    std::cout << "â•‘                                                                       â•‘\n";
    std::cout << "â•‘  \033[1mâœ\033[0m Main UI: \033[4mhttp://localhost:9000\033[0m                                   â•‘\n";
    std::cout << "â•‘  \033[1mâœ\033[0m Account UI: \033[4mhttp://localhost:3000\033[0m (when service 4 running)     â•‘\n";
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    
    // Calculate how much padding we need to fill the screen
    int lines_used = 36; // Approximate lines used by TUI (adjust based on actual content)
    if (logger && !logger->get_recent_logs(15).empty()) {
        lines_used += logger->get_recent_logs(15).size() + 6; // Add lines for request log section
    } else if (logger) {
        lines_used += 7; // Empty request log section
    }
    
    int padding_needed = term_size.rows - lines_used - 2; // -2 for command prompt
    if (padding_needed > 0) {
        for (int i = 0; i < padding_needed; i++) {
            std::cout << "\n";
        }
    }
    
    std::cout << "Command: \033[?25h" << std::flush; // Show cursor at prompt
}

void show_service_logs(ServiceManager& manager, int id) {
    auto services = manager.get_services();
    if (services.find(id) == services.end()) {
        std::cout << "\n\033[31mâœ— Service " << id << " not found\033[0m\n";
        return;
    }
    
    auto output = manager.get_service_output(id);
    auto& svc = services[id];
    
    std::cout << "\033[2J\033[H"; // Clear screen
    std::cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
    std::cout << "â•‘              ğŸ“‹ Service Logs - " << svc.name;
    for (int i = svc.name.length(); i < 42; i++) std::cout << " ";
    std::cout << "â•‘\n";
    std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    
    std::cout << "\033[90mâ”Œ" << std::string(73, '-') << "â”\033[0m\n";
    
    if (output.empty()) {
        std::cout << "\033[90mâ”‚\033[0m \033[33mNo output captured yet...\033[0m";
        for (int i = 26; i < 72; i++) std::cout << " ";
        std::cout << "\033[90mâ”‚\033[0m\n";
    } else {
        for (const auto& line : output) {
            std::cout << "\033[90mâ”‚\033[0m ";
            if (line.length() > 71) {
                std::cout << line.substr(0, 68) << "...";
            } else {
                std::cout << line;
                for (size_t i = line.length(); i < 71; i++) std::cout << " ";
            }
            std::cout << "\033[90mâ”‚\033[0m\n";
        }
    }
    
    std::cout << "\033[90mâ””" << std::string(73, '-') << "â”˜\033[0m\n\n";
    
    std::cout << "\033[36mâ„¹ï¸  Showing last " << output.size() << " lines (max 100)\033[0m\n";
    std::cout << "\033[90mPress Enter to return to main menu...\033[0m" << std::flush;
}

int main(int argc, char* argv[]) {
    std::cout << "\033[?25h"; // Show cursor
    
    // Detect if running as service_manager
    std::string program_name = "matlab_platform_demo";
    if (argc > 0) {
        std::string argv0(argv[0]);
        if (argv0.find("service_manager") != std::string::npos) {
            program_name = "service_manager";
        }
    }
    bool is_service_manager = (program_name == "service_manager");
    
    // Parse port from command line argument (default to 9001)
    int port = 9001;
    if (argc > 1) {
        port = std::atoi(argv[1]);
        if (port < 1024 || port > 65535) {
            std::cerr << "âœ— Invalid port: " << argv[1] << " (must be 1024-65535)\n";
            std::cerr << "Usage: " << argv[0] << " [port]\n";
            std::cerr << "Example: " << argv[0] << " 9001\n";
            return 1;
        }
    }
    
    if (!is_service_manager) {
        std::cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        std::cout << "â•‘        ğŸš€ MATLAB-Style Platform - Starting Services ğŸš€               â•‘\n";
        std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
    }
    
    // Check if port is in use and prompt for alternative
    bool port_available = false;
    while (!port_available) {
        std::string port_check = "lsof -ti:" + std::to_string(port) + " 2>/dev/null";
        FILE* pipe = popen(port_check.c_str(), "r");
        char buffer[128];
        std::string pid_str;
        
        if (pipe && fgets(buffer, sizeof(buffer), pipe) != nullptr) {
            pid_str = buffer;
            pid_str.erase(pid_str.find_last_not_of(" \n\r\t") + 1);
            pclose(pipe);
            
            if (!pid_str.empty()) {
                std::cout << "âš ï¸  Port " << port << " is already in use by process " << pid_str << "\n\n";
                
                int suggested_port = port + 1;
                std::cout << "Options:\n";
                std::cout << "  [Enter]     - Use port " << suggested_port << " (suggested)\n";
                std::cout << "  [number]    - Specify a different port\n";
                std::cout << "  k           - Kill process " << pid_str << " and use port " << port << "\n";
                std::cout << "  q           - Quit\n\n";
                std::cout << "Choose an option: " << std::flush;
                
                std::string response;
                std::getline(std::cin, response);
                
                if (response == "q" || response == "Q" || response == "quit") {
                    std::cout << "\nExiting...\n";
                    return 0;
                } else if (response == "k" || response == "K") {
                    std::cout << "\nâš ï¸  Attempting to kill process " << pid_str << "...\n";
                    std::string kill_cmd = "kill -9 " + pid_str;
                    int kill_result = system(kill_cmd.c_str());
                    if (kill_result == 0) {
                        std::cout << "âœ“ Process " << pid_str << " killed\n";
                        usleep(500000); // Wait for port to be released
                        std::cout << "ğŸ“Œ Retrying port " << port << "...\n";
                    } else {
                        std::cout << "âœ— Failed to kill process " << pid_str << "\n";
                        std::cout << "  Falling back to port " << suggested_port << "\n";
                        port = suggested_port;
                    }
                    continue;
                } else if (response.empty()) {
                    port = suggested_port;
                } else {
                    int new_port = std::atoi(response.c_str());
                    if (new_port < 1024 || new_port > 65535) {
                        std::cout << "âœ— Invalid port. Using suggested port " << suggested_port << "\n";
                        port = suggested_port;
                    } else {
                        port = new_port;
                    }
                }
                std::cout << "\nğŸ“Œ Trying port " << port << "...\n";
                continue;
            }
        } else if (pipe) {
            pclose(pipe);
        }
        
        port_available = true;
    }
    
    if (!is_service_manager) {
        std::cout << "\nâœ“ Port " << port << " is available\n";
        std::cout << "ğŸ“Œ Server will start on: http://localhost:" << port << "\n\n";
    }
    
    // Create authentication system
    AuthSystem auth_system;
    if (!is_service_manager) std::cout << "âœ“ Authentication system initialized\n";
    
    // Create request logger
    RequestLogger request_logger;
    if (!is_service_manager) std::cout << "âœ“ Request logger initialized\n";
    
    // Register web components
    ComponentRegistry& registry = ComponentRegistry::instance();
    registry.register_component(components::create_button());
    registry.register_component(components::create_form_input());
    registry.register_component(components::create_progress_bar());
    registry.register_component(components::create_data_table());
    if (!is_service_manager) std::cout << "âœ“ Web components registered\n";
    
    // Create service manager
    ServiceManager service_manager;
    if (!is_service_manager) std::cout << "âœ“ Service manager initialized\n\n";
    
    if (!is_service_manager) std::cout << "ğŸ”¥ Starting HTTP server on port " << port << "...\n";
    
    // Start MATLAB-style UI in background thread
    std::atomic<bool> ui_running{false};
    std::thread ui_thread([&]() {
        MATLABStyleUI ui(port, &auth_system, &request_logger, &service_manager);
        ui_running = true;
        ui.start();
    });
    
    // Wait for UI to start
    while (!ui_running) {
        usleep(100000);
    }
    
    usleep(500000); // Give UI time to bind
    
    std::cout << "\n";
    
    if (is_service_manager) {
        // Clean, minimal banner for service_manager
        std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        std::cout << "â•‘  ğŸ”¥ Service Manager Ready                                             â•‘\n";
        std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        std::cout << "â•‘  URL: \033[1mhttp://localhost:" << port << "/app/manager\033[0m";
        std::string padding(45 - std::to_string(port).length(), ' ');
        std::cout << padding << "â•‘\n";
        std::cout << "â•‘  Port: " << port << "                                                          ";
        std::string padding_port(39 - std::to_string(port).length(), ' ');
        std::cout << padding_port << "â•‘\n";
        std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n";
    } else {
        // Full verbose banner for matlab_platform_demo
        std::cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n";
        std::cout << "â•‘                    âœ… SYSTEM READY                                    â•‘\n";
        std::cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n";
        std::cout << "â•‘                                                                       â•‘\n";
        std::cout << "â•‘  ğŸŒ Web Service Manager:                                              â•‘\n";
        std::cout << "â•‘     \033[1m\033[4mhttp://localhost:" << port << "/app/manager\033[0m";
        std::string padding1(35 - std::to_string(port).length(), ' ');
        std::cout << padding1 << "â•‘\n";
        std::cout << "â•‘                                                                       â•‘\n";
        std::cout << "â•‘  ğŸ“Š Main Dashboard:                                                   â•‘\n";
        std::cout << "â•‘     \033[1m\033[4mhttp://localhost:" << port << "\033[0m";
        std::string padding2(48 - std::to_string(port).length(), ' ');
        std::cout << padding2 << "â•‘\n";
        std::cout << "â•‘                                                                       â•‘\n";
        std::cout << "â•‘  Port: " << port << " (change with: ./" << program_name << " <port>)";
        std::string padding3(30 - std::to_string(port).length(), ' ');
        std::cout << padding3 << "â•‘\n";
        std::cout << "â•‘                                                                       â•‘\n";
        std::cout << "â•‘  Features:                                                            â•‘\n";
        std::cout << "â•‘   â€¢ Real-time service monitoring                                      â•‘\n";
        std::cout << "â•‘   â€¢ HTTP request logging with thread IDs                             â•‘\n";
        std::cout << "â•‘   â€¢ Start/stop services from web GUI                                 â•‘\n";
        std::cout << "â•‘   â€¢ Thread-per-request architecture                                  â•‘\n";
        std::cout << "â•‘                                                                       â•‘\n";
        std::cout << "â•‘  Press Ctrl+C to stop the server                                      â•‘\n";
        std::cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n";
        std::cout << "Server is running... (Press Ctrl+C to stop)\n" << std::flush;
    }
    
    // Keep main thread alive
    while (true) {
        sleep(1);
    }
    
    // Cleanup
    ui_thread.detach();
    return 0;
}
