#include "security/malware_scanner.h"
#include <fstream>
#include <sstream>
#include <algorithm>
#include <ctime>
#include <iomanip>
#include <sys/stat.h>

namespace security {
namespace scanner {

// Utility functions
std::string threat_level_to_string(ThreatLevel level) {
    switch (level) {
        case ThreatLevel::SAFE: return "SAFE";
        case ThreatLevel::SUSPICIOUS: return "SUSPICIOUS";
        case ThreatLevel::DANGEROUS: return "DANGEROUS";
        case ThreatLevel::CRITICAL: return "CRITICAL";
        default: return "UNKNOWN";
    }
}

std::vector<char> read_file_bytes(const std::string& filepath) {
    std::ifstream file(filepath, std::ios::binary);
    if (!file) return {};
    
    file.seekg(0, std::ios::end);
    size_t size = file.tellg();
    file.seekg(0, std::ios::beg);
    
    std::vector<char> buffer(size);
    file.read(buffer.data(), size);
    return buffer;
}

bool write_file_bytes(const std::string& filepath, const std::vector<char>& content) {
    std::ofstream file(filepath, std::ios::binary);
    if (!file) return false;
    
    file.write(content.data(), content.size());
    return file.good();
}

// ScanResult implementation
std::string ScanResult::to_string() const {
    std::stringstream ss;
    ss << "Scan Result:\n";
    ss << "  Status: " << (is_safe ? "SAFE" : "THREAT DETECTED") << "\n";
    ss << "  Threat Level: " << threat_level_to_string(threat_level) << "\n";
    ss << "  Bytes Scanned: " << bytes_scanned << "\n";
    ss << "  Scan Duration: " << std::fixed << std::setprecision(2) << scan_duration_ms << " ms\n";
    
    if (!threats_found.empty()) {
        ss << "  Threats Found (" << threats_found.size() << "):\n";
        for (const auto& threat : threats_found) {
            ss << "    - " << threat << "\n";
        }
    }
    
    if (!details.empty()) {
        ss << "  Details:\n";
        for (const auto& [key, value] : details) {
            ss << "    " << key << ": " << value << "\n";
        }
    }
    
    return ss.str();
}

// MalwareScanner implementation
MalwareScanner::MalwareScanner()
    : quarantine_path_("/tmp/quarantine/"),
      max_file_size_(100 * 1024 * 1024),  // 100MB
      scan_archives_(true),
      heuristic_analysis_(true),
      deep_scan_(false),
      total_scans_(0),
      threats_detected_(0) {
    
    // Load default signatures
    load_default_rules();
}

void MalwareScanner::load_default_rules() {
    // Malicious code patterns
    add_signature({
        "Generic.Malware.Shell",
        "Shell command execution patterns",
        {"system(", "exec(", "shell_exec", "popen(", "proc_open"},
        ThreatLevel::DANGEROUS,
        "code_injection"
    });
    
    add_signature({
        "Generic.Malware.SQLInjection",
        "SQL injection patterns",
        {"DROP TABLE", "UNION SELECT", "'; DROP", "1' OR '1'='1"},
        ThreatLevel::DANGEROUS,
        "sql_injection"
    });
    
    add_signature({
        "Generic.Malware.PathTraversal",
        "Path traversal patterns",
        {"../", "..\\", "%2e%2e", "....//"},
        ThreatLevel::DANGEROUS,
        "path_traversal"
    });
    
    add_signature({
        "Generic.Trojan.Base64",
        "Base64 encoded payload indicators",
        {"eval(base64_decode", "base64_decode(", "FromBase64String"},
        ThreatLevel::SUSPICIOUS,
        "obfuscation"
    });
    
    add_signature({
        "Generic.Ransomware.Encrypt",
        "Ransomware encryption indicators",
        {"AES.Encrypt", "RSA.Encrypt", ".encrypted", ".locked", "ransom"},
        ThreatLevel::CRITICAL,
        "ransomware"
    });
    
    add_signature({
        "Generic.Backdoor.Remote",
        "Remote backdoor indicators",
        {"reverse_shell", "bind_shell", "nc -e", "tcp_connect"},
        ThreatLevel::CRITICAL,
        "backdoor"
    });
    
    // Content rules
    add_content_rule({
        "Suspicious Script Tag",
        std::regex(R"(<script[^>]*>.*?<\/script>)", std::regex::icase),
        ThreatLevel::SUSPICIOUS,
        "Embedded JavaScript detected",
        false
    });
    
    add_content_rule({
        "Embedded PHP Code",
        std::regex(R"(<\?php|<\?=)"),
        ThreatLevel::DANGEROUS,
        "PHP code detected in content",
        true
    });
    
    add_content_rule({
        "Suspicious URL Pattern",
        std::regex(R"((http|https|ftp)://[^\s]+\.(exe|scr|bat|cmd|vbs|js))"),
        ThreatLevel::DANGEROUS,
        "Suspicious executable URL",
        false
    });
}

void MalwareScanner::add_signature(const MalwareSignature& signature) {
    signatures_.push_back(signature);
}

void MalwareScanner::add_content_rule(const ContentRule& rule) {
    content_rules_.push_back(rule);
}

ScanResult MalwareScanner::scan_file(const std::string& filepath) {
    auto content = read_file_bytes(filepath);
    if (content.empty()) {
        ScanResult result;
        result.is_safe = false;
        result.threat_level = ThreatLevel::SUSPICIOUS;
        result.threats_found.push_back("Unable to read file: " + filepath);
        result.bytes_scanned = 0;
        return result;
    }
    
    return scan_content(content, filepath);
}

ScanResult MalwareScanner::scan_content(const std::vector<char>& content, const std::string& filename) {
    return perform_scan(content, filename);
}

ScanResult MalwareScanner::scan_text(const std::string& text) {
    std::vector<char> content(text.begin(), text.end());
    return perform_scan(content, "text_content");
}

ScanResult MalwareScanner::perform_scan(const std::vector<char>& content, const std::string& context) {
    auto start_time = std::chrono::high_resolution_clock::now();
    
    ScanResult result;
    result.bytes_scanned = content.size();
    result.scan_time = std::chrono::system_clock::now();
    result.is_safe = true;
    result.threat_level = ThreatLevel::SAFE;
    
    total_scans_++;
    
    // Check file size limit
    if (content.size() > max_file_size_) {
        result.is_safe = false;
        result.threat_level = ThreatLevel::SUSPICIOUS;
        result.threats_found.push_back("File exceeds maximum size limit");
    }
    
    // Detect file type
    std::string file_type = detect_file_type(content);
    result.details["file_type"] = file_type;
    
    // Check if executable
    if (is_executable(content)) {
        result.details["is_executable"] = "true";
        result.threats_found.push_back("Executable file detected");
        result.threat_level = ThreatLevel::SUSPICIOUS;
    }
    
    // Signature-based detection
    std::vector<std::string> sig_threats;
    if (check_signatures(content, sig_threats)) {
        result.threats_found.insert(result.threats_found.end(), sig_threats.begin(), sig_threats.end());
    }
    
    // Content rule checking
    std::string content_str(content.begin(), content.end());
    std::vector<std::string> rule_threats;
    if (check_content_rules(content_str, rule_threats)) {
        result.threats_found.insert(result.threats_found.end(), rule_threats.begin(), rule_threats.end());
    }
    
    // Heuristic analysis
    if (heuristic_analysis_) {
        std::vector<std::string> heuristic_threats;
        if (check_heuristics(content, heuristic_threats)) {
            result.threats_found.insert(result.threats_found.end(), heuristic_threats.begin(), heuristic_threats.end());
        }
    }
    
    // Calculate final threat level
    if (!result.threats_found.empty()) {
        result.is_safe = false;
        result.threat_level = calculate_threat_level(result.threats_found);
        threats_detected_++;
    }
    
    auto end_time = std::chrono::high_resolution_clock::now();
    result.scan_duration_ms = std::chrono::duration<double, std::milli>(end_time - start_time).count();
    
    return result;
}

bool MalwareScanner::check_signatures(const std::vector<char>& content, std::vector<std::string>& threats) {
    bool found = false;
    
    for (const auto& sig : signatures_) {
        for (const auto& pattern : sig.patterns) {
            if (contains_pattern(content, pattern)) {
                threats.push_back(sig.name + ": " + sig.description);
                found = true;
                break;
            }
        }
    }
    
    return found;
}

bool MalwareScanner::check_content_rules(const std::string& text, std::vector<std::string>& threats) {
    bool found = false;
    
    for (const auto& rule : content_rules_) {
        if (std::regex_search(text, rule.pattern)) {
            threats.push_back(rule.name + ": " + rule.description);
            found = true;
        }
    }
    
    return found;
}

bool MalwareScanner::check_heuristics(const std::vector<char>& content, std::vector<std::string>& threats) {
    bool found = false;
    
    // Check entropy (high entropy might indicate encryption/obfuscation)
    std::map<char, int> freq;
    for (char c : content) {
        freq[c]++;
    }
    
    double entropy = 0.0;
    for (const auto& [c, count] : freq) {
        double p = static_cast<double>(count) / content.size();
        entropy -= p * std::log2(p);
    }
    
    if (entropy > 7.5) {
        threats.push_back("High entropy detected (possible encryption/packing)");
        found = true;
    }
    
    // Check for suspicious byte sequences
    std::string content_str(content.begin(), content.end());
    
    // Check for null bytes in text (suspicious)
    size_t null_count = std::count(content.begin(), content.end(), '\0');
    if (null_count > content.size() * 0.1) {
        threats.push_back("High number of null bytes detected");
        found = true;
    }
    
    // Check for long base64 strings
    std::regex base64_regex(R"([A-Za-z0-9+/]{100,}={0,2})");
    if (std::regex_search(content_str, base64_regex)) {
        threats.push_back("Long base64 encoded string detected");
        found = true;
    }
    
    return found;
}

ThreatLevel MalwareScanner::calculate_threat_level(const std::vector<std::string>& threats) {
    int max_level = 0;
    
    for (const auto& threat : threats) {
        if (threat.find("CRITICAL") != std::string::npos || 
            threat.find("ransomware") != std::string::npos ||
            threat.find("backdoor") != std::string::npos) {
            max_level = std::max(max_level, 3);
        } else if (threat.find("DANGEROUS") != std::string::npos ||
                   threat.find("injection") != std::string::npos) {
            max_level = std::max(max_level, 2);
        } else if (threat.find("SUSPICIOUS") != std::string::npos ||
                   threat.find("Executable") != std::string::npos) {
            max_level = std::max(max_level, 1);
        }
    }
    
    switch (max_level) {
        case 3: return ThreatLevel::CRITICAL;
        case 2: return ThreatLevel::DANGEROUS;
        case 1: return ThreatLevel::SUSPICIOUS;
        default: return ThreatLevel::SAFE;
    }
}

bool MalwareScanner::contains_pattern(const std::vector<char>& content, const std::string& pattern) {
    std::string content_str(content.begin(), content.end());
    return content_str.find(pattern) != std::string::npos;
}

std::string MalwareScanner::detect_file_type(const std::vector<char>& content) {
    if (content.size() < 4) return "unknown";
    
    // Check magic numbers (cast to unsigned char to avoid signed comparison issues)
    auto uc = [&](size_t i) { return static_cast<unsigned char>(content[i]); };
    
    if (uc(0) == 0x4D && uc(1) == 0x5A) return "PE executable";
    if (uc(0) == 0x7F && uc(1) == 0x45 && uc(2) == 0x4C && uc(3) == 0x46) return "ELF executable";
    if (uc(0) == 0x50 && uc(1) == 0x4B) return "ZIP archive";
    if (uc(0) == 0x25 && uc(1) == 0x50 && uc(2) == 0x44 && uc(3) == 0x46) return "PDF document";
    if (uc(0) == 0xFF && uc(1) == 0xD8 && uc(2) == 0xFF) return "JPEG image";
    if (uc(0) == 0x89 && uc(1) == 0x50 && uc(2) == 0x4E && uc(3) == 0x47) return "PNG image";
    
    std::string start(content.begin(), content.begin() + std::min(content.size(), size_t(100)));
    if (start.find("<?php") != std::string::npos) return "PHP script";
    if (start.find("#!/bin/bash") != std::string::npos || start.find("#!/bin/sh") != std::string::npos) return "Shell script";
    if (start.find("python") != std::string::npos) return "Python script";
    
    return "text/binary";
}

bool MalwareScanner::is_executable(const std::vector<char>& content) {
    if (content.size() < 4) return false;
    
    // Check for PE/ELF headers (cast to unsigned char)
    auto uc = [&](size_t i) { return static_cast<unsigned char>(content[i]); };
    
    if (uc(0) == 0x4D && uc(1) == 0x5A) return true;  // PE
    if (uc(0) == 0x7F && uc(1) == 0x45 && uc(2) == 0x4C && uc(3) == 0x46) return true;  // ELF
    if (uc(0) == 0xCF && uc(1) == 0xFA) return true;  // Mach-O
    
    return false;
}

void MalwareScanner::reset_statistics() {
    total_scans_ = 0;
    threats_detected_ = 0;
}

// EmailSecurityScanner implementation
EmailSecurityScanner::EmailSecurityScanner()
    : max_attachment_size_(10 * 1024 * 1024),  // 10MB
      block_executables_(true) {
}

EmailSecurityScanner::EmailScanResult EmailSecurityScanner::scan_email(
    const std::string& subject,
    const std::string& from,
    const std::string& body,
    const std::vector<std::pair<std::string, std::vector<char>>>& attachments) {
    
    EmailScanResult result;
    result.is_safe = true;
    
    // Scan email body
    result.body_scan = scanner_.scan_text(body);
    if (!result.body_scan.is_safe) {
        result.is_safe = false;
    }
    
    // Check for phishing
    result.has_phishing_indicators = check_phishing(subject, from, body);
    if (result.has_phishing_indicators) {
        result.warnings.push_back("Phishing indicators detected");
        result.is_safe = false;
    }
    
    // Check for spam
    result.has_spam_indicators = check_spam(subject, body);
    
    // Check for suspicious links
    result.has_suspicious_links = check_suspicious_links(body);
    if (result.has_suspicious_links) {
        result.warnings.push_back("Suspicious URLs detected");
    }
    
    // Scan attachments
    for (const auto& [filename, content] : attachments) {
        if (content.size() > max_attachment_size_) {
            result.warnings.push_back("Attachment too large: " + filename);
            result.is_safe = false;
            continue;
        }
        
        auto scan = scanner_.scan_content(content, filename);
        result.attachment_scans.push_back(scan);
        
        if (!scan.is_safe) {
            result.is_safe = false;
        }
        
        // Check if executable attachment
        if (block_executables_ && scanner_.is_executable(content)) {
            result.warnings.push_back("Executable attachment blocked: " + filename);
            result.is_safe = false;
        }
    }
    
    return result;
}

bool EmailSecurityScanner::check_phishing(const std::string& subject, const std::string& from, const std::string& body) {
    std::regex phishing_patterns[] = {
        std::regex(R"(verify.*account)", std::regex::icase),
        std::regex(R"(urgent.*action)", std::regex::icase),
        std::regex(R"(suspended.*account)", std::regex::icase),
        std::regex(R"(click.*here.*immediately)", std::regex::icase),
        std::regex(R"(confirm.*identity)", std::regex::icase),
        std::regex(R"(reset.*password)", std::regex::icase)
    };
    
    std::string combined = subject + " " + body;
    for (const auto& pattern : phishing_patterns) {
        if (std::regex_search(combined, pattern)) {
            return true;
        }
    }
    
    return false;
}

bool EmailSecurityScanner::check_spam(const std::string& subject, const std::string& body) {
    std::regex spam_patterns[] = {
        std::regex(R"(buy now|act now|limited time)", std::regex::icase),
        std::regex(R"(free money|make money fast)", std::regex::icase),
        std::regex(R"(viagra|cialis|pharmacy)", std::regex::icase)
    };
    
    std::string combined = subject + " " + body;
    for (const auto& pattern : spam_patterns) {
        if (std::regex_search(combined, pattern)) {
            return true;
        }
    }
    
    return false;
}

bool EmailSecurityScanner::check_suspicious_links(const std::string& body) {
    auto links = extract_links(body);
    
    std::regex suspicious_patterns[] = {
        std::regex(R"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})"),  // IP addresses
        std::regex(R"(bit\.ly|tinyurl|goo\.gl)", std::regex::icase),  // URL shorteners
        std::regex(R"(\.(exe|scr|bat|cmd|vbs)$)", std::regex::icase)  // Executable extensions
    };
    
    for (const auto& link : links) {
        for (const auto& pattern : suspicious_patterns) {
            if (std::regex_search(link, pattern)) {
                return true;
            }
        }
    }
    
    return false;
}

std::vector<std::string> EmailSecurityScanner::extract_links(const std::string& text) {
    std::vector<std::string> links;
    std::regex url_regex(R"((https?|ftp)://[^\s<>"{}|\\^`\[\]]+)");
    
    auto begin = std::sregex_iterator(text.begin(), text.end(), url_regex);
    auto end = std::sregex_iterator();
    
    for (auto it = begin; it != end; ++it) {
        links.push_back(it->str());
    }
    
    return links;
}

// FileUploadScanner implementation
FileUploadScanner::FileUploadScanner()
    : max_upload_size_(50 * 1024 * 1024),  // 50MB
      auto_sanitize_(true) {
    
    // Common safe extensions
    allowed_extensions_ = {".txt", ".pdf", ".jpg", ".jpeg", ".png", ".gif", ".csv", ".json", ".xml"};
}

FileUploadScanner::UploadScanResult FileUploadScanner::scan_upload(
    const std::string& filename,
    const std::vector<char>& content,
    const std::vector<std::string>& allowed_extensions) {
    
    UploadScanResult result;
    result.allowed = true;
    result.needs_sanitization = false;
    result.sanitized_filename = filename;
    
    // Check for path traversal
    if (has_path_traversal(filename)) {
        result.allowed = false;
        result.rejection_reason = "Path traversal detected in filename";
        return result;
    }
    
    // Sanitize filename if needed
    if (auto_sanitize_) {
        result.sanitized_filename = sanitize_filename(filename);
        result.needs_sanitization = (result.sanitized_filename != filename);
    }
    
    // Check file size
    if (content.size() > max_upload_size_) {
        result.allowed = false;
        result.rejection_reason = "File exceeds maximum upload size";
        return result;
    }
    
    // Check extension
    auto extensions = allowed_extensions.empty() ? allowed_extensions_ : allowed_extensions;
    bool ext_ok = false;
    for (const auto& ext : extensions) {
        if (filename.size() >= ext.size() && 
            filename.compare(filename.size() - ext.size(), ext.size(), ext) == 0) {
            ext_ok = true;
            break;
        }
    }
    
    if (!ext_ok) {
        result.allowed = false;
        result.rejection_reason = "File extension not allowed";
        return result;
    }
    
    // Scan content
    result.scan_result = scanner_.scan_content(content, filename);
    if (!result.scan_result.is_safe) {
        result.allowed = false;
        result.rejection_reason = "Security scan failed: malicious content detected";
    }
    
    return result;
}

std::string FileUploadScanner::sanitize_filename(const std::string& filename) {
    std::string safe = filename;
    
    // Remove path components
    size_t last_slash = safe.find_last_of("/\\");
    if (last_slash != std::string::npos) {
        safe = safe.substr(last_slash + 1);
    }
    
    // Remove dangerous characters
    std::string allowed = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_. ";
    std::string result;
    
    for (char c : safe) {
        if (allowed.find(c) != std::string::npos) {
            result += c;
        } else {
            result += '_';
        }
    }
    
    return result;
}

bool FileUploadScanner::has_path_traversal(const std::string& filename) {
    return filename.find("..") != std::string::npos ||
           filename.find("./") != std::string::npos ||
           filename.find(":\\") != std::string::npos;
}

void FileUploadScanner::add_allowed_extension(const std::string& ext) {
    allowed_extensions_.push_back(ext);
}

ScanResult MalwareScanner::scan_email(const std::string& email_content) {
    return scan_text(email_content);
}

} // namespace scanner
} // namespace security
