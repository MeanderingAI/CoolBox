#pragma once

#include <string>
#include <vector>
#include <map>
#include <memory>
#include <regex>
#include <functional>
#include <chrono>

namespace security {
namespace scanner {

// Threat levels
enum class ThreatLevel {
    SAFE,
    SUSPICIOUS,
    DANGEROUS,
    CRITICAL
};

// Scan result
struct ScanResult {
    bool is_safe;
    ThreatLevel threat_level;
    std::vector<std::string> threats_found;
    std::map<std::string, std::string> details;
    std::chrono::system_clock::time_point scan_time;
    size_t bytes_scanned;
    double scan_duration_ms;
    
    std::string to_string() const;
};

// Malware signature
struct MalwareSignature {
    std::string name;
    std::string description;
    std::vector<std::string> patterns;  // Hex patterns or strings
    ThreatLevel severity;
    std::string category;  // virus, trojan, ransomware, etc.
};

// Content filter rule
struct ContentRule {
    std::string name;
    std::regex pattern;
    ThreatLevel severity;
    std::string description;
    bool case_sensitive;
};

class MalwareScanner {
public:
    MalwareScanner();
    ~MalwareScanner() = default;
    
    // Scan operations
    ScanResult scan_file(const std::string& filepath);
    ScanResult scan_content(const std::vector<char>& content, const std::string& filename = "");
    ScanResult scan_text(const std::string& text);
    ScanResult scan_email(const std::string& email_content);
    
    // Signature management
    void add_signature(const MalwareSignature& signature);
    void load_signature_database(const std::string& db_path);
    void update_signatures();
    size_t get_signature_count() const { return signatures_.size(); }
    
    // Content rules
    void add_content_rule(const ContentRule& rule);
    void load_default_rules();
    
    // Configuration
    void set_max_file_size(size_t max_bytes) { max_file_size_ = max_bytes; }
    void set_scan_archives(bool enable) { scan_archives_ = enable; }
    void set_heuristic_analysis(bool enable) { heuristic_analysis_ = enable; }
    void set_deep_scan(bool enable) { deep_scan_ = enable; }
    
    // Statistics
    size_t get_total_scans() const { return total_scans_; }
    size_t get_threats_detected() const { return threats_detected_; }
    void reset_statistics();
    
    // Quarantine management
    bool quarantine_file(const std::string& filepath, const ScanResult& result);
    std::vector<std::string> list_quarantine() const;
    bool restore_from_quarantine(const std::string& filename);
    
private:
    std::vector<MalwareSignature> signatures_;
    std::vector<ContentRule> content_rules_;
    std::string quarantine_path_;
    size_t max_file_size_;
    bool scan_archives_;
    bool heuristic_analysis_;
    bool deep_scan_;
    size_t total_scans_;
    size_t threats_detected_;
    
    // Internal scanning methods
    ScanResult perform_scan(const std::vector<char>& content, const std::string& context);
    bool check_signatures(const std::vector<char>& content, std::vector<std::string>& threats);
    bool check_content_rules(const std::string& text, std::vector<std::string>& threats);
    bool check_heuristics(const std::vector<char>& content, std::vector<std::string>& threats);
    ThreatLevel calculate_threat_level(const std::vector<std::string>& threats);
    
    // Pattern matching
    bool contains_pattern(const std::vector<char>& content, const std::string& pattern);
    bool contains_hex_pattern(const std::vector<char>& content, const std::string& hex_pattern);
    
    // File type detection
    std::string detect_file_type(const std::vector<char>& content);
    bool is_script(const std::vector<char>& content);
    bool is_archive(const std::vector<char>& content);

public:
    bool is_executable(const std::vector<char>& content);
};

// Email security scanner
class EmailSecurityScanner {
public:
    EmailSecurityScanner();
    
    struct EmailScanResult {
        bool is_safe;
        ScanResult body_scan;
        std::vector<ScanResult> attachment_scans;
        bool has_suspicious_links;
        bool has_phishing_indicators;
        bool has_spam_indicators;
        std::vector<std::string> warnings;
    };
    
    EmailScanResult scan_email(
        const std::string& subject,
        const std::string& from,
        const std::string& body,
        const std::vector<std::pair<std::string, std::vector<char>>>& attachments
    );
    
    void set_max_attachment_size(size_t bytes) { max_attachment_size_ = bytes; }
    void set_block_executables(bool block) { block_executables_ = block; }
    
private:
    MalwareScanner scanner_;
    size_t max_attachment_size_;
    bool block_executables_;
    
    bool check_phishing(const std::string& subject, const std::string& from, const std::string& body);
    bool check_spam(const std::string& subject, const std::string& body);
    bool check_suspicious_links(const std::string& body);
    std::vector<std::string> extract_links(const std::string& text);
};

// File upload security scanner
class FileUploadScanner {
public:
    FileUploadScanner();
    
    struct UploadScanResult {
        bool allowed;
        ScanResult scan_result;
        std::string rejection_reason;
        std::string sanitized_filename;
        bool needs_sanitization;
    };
    
    UploadScanResult scan_upload(
        const std::string& filename,
        const std::vector<char>& content,
        const std::vector<std::string>& allowed_extensions = {}
    );
    
    void add_allowed_extension(const std::string& ext);
    void set_max_upload_size(size_t bytes) { max_upload_size_ = bytes; }
    void set_auto_sanitize_filenames(bool enable) { auto_sanitize_ = enable; }
    
private:
    MalwareScanner scanner_;
    std::vector<std::string> allowed_extensions_;
    size_t max_upload_size_;
    bool auto_sanitize_;
    
    std::string sanitize_filename(const std::string& filename);
    bool is_extension_allowed(const std::string& filename);
    bool has_path_traversal(const std::string& filename);
};

// Utility functions
std::string threat_level_to_string(ThreatLevel level);
std::vector<char> read_file_bytes(const std::string& filepath);
bool write_file_bytes(const std::string& filepath, const std::vector<char>& content);

} // namespace scanner
} // namespace security
